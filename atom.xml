<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harry-积少成多</title>
  
  
  <link href="/Harry.github.io/atom.xml" rel="self"/>
  
  <link href="https://cq-harry.github.io/Harry.github.io/"/>
  <updated>2018-03-20T07:59:59.445Z</updated>
  <id>https://cq-harry.github.io/Harry.github.io/</id>
  
  <author>
    <name>Harry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自己手写一个SpringMVC框架</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/17/%E8%87%AA%E5%B7%B1%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AASpringMVC%E6%A1%86%E6%9E%B6/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/17/自己手写一个SpringMVC框架/</id>
    <published>2018-03-17T10:30:32.000Z</published>
    <updated>2018-03-20T07:59:59.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文转自liugh-develop"><a href="#本文转自liugh-develop" class="headerlink" title="本文转自liugh_develop"></a>本文转自<a href="https://my.oschina.net/liughDevelop/blog/1622646" title="liugh_develop" target="_blank" rel="noopener">liugh_develop</a></h2><blockquote><p>摘要: 前端框架很多,但没有一个框架称霸,后端框架现在Spring已经完成大一统.所以学习Spring是Java程序员的必修课.</p><p>Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一个月的代码，最后还得其他老司机花3天时间重构，相信大部分老司机都很头疼看新手的代码。</p><p>废话不多说，我们进入今天的正题，在Web应用程序设计中，MVC模式已经被广泛使用。SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。想要实现自己的SpringMVC框架，需要从以下几点入手：</p></blockquote><a id="more"></a><h4 id="一、了解SpringMVC运行流程及九大组件"><a href="#一、了解SpringMVC运行流程及九大组件" class="headerlink" title="一、了解SpringMVC运行流程及九大组件"></a>一、了解SpringMVC运行流程及九大组件</h4><h5 id="1-SpringMVC的运行流程"><a href="#1-SpringMVC的运行流程" class="headerlink" title="1.SpringMVC的运行流程"></a>1.SpringMVC的运行流程</h5><p><a href="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1520242763909_091846_FTTR_3577599.png" target="_blank" rel="noopener"><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1520242763909_091846_FTTR_3577599.png" alt=""></a></p><p>（1）用户发送请求至前端控制器DispatcherServlet</p><p>（2）DispatcherServlet收到请求调用HandlerMapping处理器映射器</p><p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet</p><p>（4）DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p><p>（5）执行处理器(Controller，也叫后端控制器)</p><p>（6）Controller执行完成返回ModelAndView</p><p>（7）HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</p><p>（8）DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p><p>（9）ViewReslover解析后返回具体View</p><p>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</p><p>（11）DispatcherServlet响应用户</p><p>从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。</p><h5 id="2-SpringMVC的九大组件（ref：【SpringMVC】9大组件概览）"><a href="#2-SpringMVC的九大组件（ref：【SpringMVC】9大组件概览）" class="headerlink" title="2.SpringMVC的九大组件（ref：【SpringMVC】9大组件概览）"></a>2.SpringMVC的九大组件（ref：<a href="http://blog.csdn.net/hu_zhiting/article/details/73648939" title="【SpringMVC】9大组件概览" target="_blank" rel="noopener">【SpringMVC】9大组件概览</a>）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File.</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    <span class="comment">//SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</span></span><br><span class="line">    initLocaleResolver(context); </span><br><span class="line">    <span class="comment">//用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、</span></span><br><span class="line">    <span class="comment">//如图片、css样式等。SpringMVC的主题也支持国际化， </span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">//用来查找Handler的。</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">//从名字上看，它就是一个适配器。Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。</span></span><br><span class="line">    <span class="comment">//如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">//其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？</span></span><br><span class="line">    <span class="comment">//这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="comment">//有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，</span></span><br><span class="line">    <span class="comment">//如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">//ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。</span></span><br><span class="line">    <span class="comment">//View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    <span class="comment">//用来管理FlashMap的，FlashMap主要用在redirect重定向中传递参数。</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、梳理自己的SpringMVC的设计思路"><a href="#二、梳理自己的SpringMVC的设计思路" class="headerlink" title="二、梳理自己的SpringMVC的设计思路"></a>二、梳理自己的SpringMVC的设计思路</h4><p>本文只实现自己的<code>@Controller、@RequestMapping、@RequestParam</code>注解起作用，其余SpringMVC功能读者可以尝试自己实现。</p><h5 id="1-读取配置"><a href="#1-读取配置" class="headerlink" title="1.读取配置"></a>1.读取配置</h5><p><a href="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1520317023514_110356_8w7N_3577599.png" target="_blank" rel="noopener"><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1520317023514_110356_8w7N_3577599.png" alt=""></a><br>从图中可以看出，SpringMVC本质上是一个Servlet,这个 Servlet 继承自 HttpServlet。FrameworkServlet负责初始化SpringMVC的容器，并将Spring容器设置为父容器。因为本文只是实现SpringMVC，对于Spring容器不做过多讲解（有兴趣同学可以看看我另一篇文章：<a href="https://my.oschina.net/liughDevelop/blog/1434547" title="向spring大佬低头--大量源码流出解析" target="_blank" rel="noopener">向spring大佬低头–大量源码流出解析</a>）。<br>为了读取web.xml中的配置，我们用到ServletConfig这个类，它代表当前Servlet在web.xml中的配置信息。通过web.xml中加载我们自己写的MyDispatcherServlet和读取配置文件。</p><h5 id="2-初始化阶段"><a href="#2-初始化阶段" class="headerlink" title="2.初始化阶段"></a>2.初始化阶段</h5><p>在前面我们提到DispatcherServlet的initStrategies方法会初始化9大组件，但是这里将实现一些SpringMVC的最基本的组件而不是全部，按顺序包括：</p><ul><li>加载配置文件</li><li>扫描用户配置包下面所有的类</li><li>拿到扫描到的类，通过反射机制，实例化。并且放到ioc容器中(Map的键值对  beanName-bean) beanName默认是首字母小写</li><li>初始化HandlerMapping，这里其实就是把url和method对应起来放在一个k-v的Map中,在运行阶段取出</li></ul><h5 id="3-运行阶段"><a href="#3-运行阶段" class="headerlink" title="3.运行阶段"></a>3.运行阶段</h5><p>每一次请求将会调用doGet或doPost方法，所以统一运行阶段都放在doDispatch方法里处理，它会根据url请求去HandlerMapping中匹配到对应的Method，然后利用反射机制调用Controller中的url对应的方法，并得到结果返回。按顺序包括以下功能：</p><ul><li>异常的拦截</li><li>获取请求传入的参数并处理参数</li><li>通过初始化好的handlerMapping中拿出url对应的方法名，反射调用</li></ul><h4 id="三、实现自己的SpringMVC框架"><a href="#三、实现自己的SpringMVC框架" class="headerlink" title="三、实现自己的SpringMVC框架"></a>三、实现自己的SpringMVC框架</h4><p>工程文件及目录：</p><p><a href="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1520317385379_微信截图_20180306142242.png" target="_blank" rel="noopener"><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1520317385379_微信截图_20180306142242.png" alt=""></a></p><h6 id="1-首先，新建一个maven项目，在pom-xml中导入以下依赖："><a href="#1-首先，新建一个maven项目，在pom-xml中导入以下依赖：" class="headerlink" title="1.首先，新建一个maven项目，在pom.xml中导入以下依赖："></a>1.首先，新建一个maven项目，在pom.xml中导入以下依赖：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liugh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>liughMVC<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="2-我们在WEB-INF下创建一个web-xml，如下配置："><a href="#2-我们在WEB-INF下创建一个web-xml，如下配置：" class="headerlink" title="2.我们在WEB-INF下创建一个web.xml，如下配置："></a>2.我们在WEB-INF下创建一个web.xml，如下配置：</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.liugh.servlet.MyDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="3-application-properties文件中只是配置要扫描的包到SpringMVC容器中"><a href="#3-application-properties文件中只是配置要扫描的包到SpringMVC容器中" class="headerlink" title="3.application.properties文件中只是配置要扫描的包到SpringMVC容器中"></a>3.application.properties文件中只是配置要扫描的包到SpringMVC容器中</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanPackage=com.liugh.core</span><br></pre></td></tr></table></figure><h6 id="4-创建自己的Controller注解，它只能标注在类上面："><a href="#4-创建自己的Controller注解，它只能标注在类上面：" class="headerlink" title="4.创建自己的Controller注解，它只能标注在类上面："></a>4.创建自己的Controller注解，它只能标注在类上面：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liugh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyController &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示给controller注册别名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-RequestMapping注解，可以在类和方法上："><a href="#5-RequestMapping注解，可以在类和方法上：" class="headerlink" title="5.RequestMapping注解，可以在类和方法上："></a>5.RequestMapping注解，可以在类和方法上：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liugh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyRequestMapping &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示访问该方法的url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="6-RequestParam注解-只能注解在参数上"><a href="#6-RequestParam注解-只能注解在参数上" class="headerlink" title="6.RequestParam注解,只能注解在参数上"></a>6.RequestParam注解,只能注解在参数上</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liugh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyRequestParam &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示参数的别名，必填</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能："><a href="#7-创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能：" class="headerlink" title="7.创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能："></a>7.创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liugh.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liugh.annotation.MyController;</span><br><span class="line"><span class="keyword">import</span> com.liugh.annotation.MyRequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Method&gt; handlerMapping = <span class="keyword">new</span>  HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; controllerMap  =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.加载配置文件</span></span><br><span class="line">doLoadConfig(config.getInitParameter(<span class="string">"contextConfigLocation"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.初始化所有相关联的类,扫描用户设定的包下面所有的类</span></span><br><span class="line">doScanner(properties.getProperty(<span class="string">"scanPackage"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v  beanName-bean) beanName默认是首字母小写</span></span><br><span class="line">doInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.初始化HandlerMapping(将url和method对应上)</span></span><br><span class="line">initHandlerMapping();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.doPost(req,resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//处理请求</span></span><br><span class="line">doDispatch(req,resp);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">resp.getWriter().write(<span class="string">"500!! Server Exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(handlerMapping.isEmpty())&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String url =req.getRequestURI();</span><br><span class="line">String contextPath = req.getContextPath();</span><br><span class="line">url=url.replace(contextPath, <span class="string">""</span>).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">this</span>.handlerMapping.containsKey(url))&#123;</span><br><span class="line">resp.getWriter().write(<span class="string">"404 NOT FOUND!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Method method =<span class="keyword">this</span>.handlerMapping.get(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法的参数列表</span></span><br><span class="line">Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"><span class="comment">//获取请求的参数</span></span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</span><br><span class="line"><span class="comment">//保存参数值</span></span><br><span class="line">Object [] paramValues= <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line"><span class="comment">//方法的参数列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;parameterTypes.length; i++)&#123;</span><br><span class="line"><span class="comment">//根据参数名称，做某些处理</span></span><br><span class="line">String requestParam = parameterTypes[i].getSimpleName();</span><br><span class="line"><span class="keyword">if</span> (requestParam.equals(<span class="string">"HttpServletRequest"</span>))&#123;</span><br><span class="line"><span class="comment">//参数类型已明确，这边强转类型</span></span><br><span class="line">paramValues[i]=req;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (requestParam.equals(<span class="string">"HttpServletResponse"</span>))&#123;</span><br><span class="line">paramValues[i]=resp;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(requestParam.equals(<span class="string">"String"</span>))&#123;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</span><br><span class="line">String value =Arrays.toString(param.getValue()).replaceAll(<span class="string">"\\[|\\]"</span>, <span class="string">""</span>).replaceAll(<span class="string">",\\s"</span>, <span class="string">","</span>);</span><br><span class="line">paramValues[i]=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用反射机制来调用</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">method.invoke(<span class="keyword">this</span>.controllerMap.get(url), paramValues);<span class="comment">//第一个参数是method所对应的实例 在ioc容器中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">doLoadConfig</span><span class="params">(String location)</span></span>&#123;</span><br><span class="line"><span class="comment">//把web.xml中的contextConfigLocation对应value值的文件加载到流里面</span></span><br><span class="line">InputStream resourceAsStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(location);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//用Properties文件加载文件里的内容</span></span><br><span class="line">properties.load(resourceAsStream);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//关流</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>!=resourceAsStream)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">resourceAsStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line"><span class="comment">//把所有的.替换成/</span></span><br><span class="line">URL url  =<span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"/"</span>+packageName.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>));</span><br><span class="line">File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line"><span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line"><span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line"><span class="comment">//递归读取包</span></span><br><span class="line">doScanner(packageName+<span class="string">"."</span>+file.getName());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">String className =packageName +<span class="string">"."</span> +file.getName().replace(<span class="string">".class"</span>, <span class="string">""</span>);</span><br><span class="line">classNames.add(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//把类搞出来,反射来实例化(只有加@MyController需要实例化)</span></span><br><span class="line">Class&lt;?&gt; clazz =Class.forName(className);</span><br><span class="line">   <span class="keyword">if</span>(clazz.isAnnotationPresent(MyController.class))&#123;</span><br><span class="line">ioc.put(toLowerFirstWord(clazz.getSimpleName()),clazz.newInstance());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ioc.isEmpty())&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Object&gt; entry: ioc.entrySet()) &#123;</span><br><span class="line">Class&lt;? extends Object&gt; clazz = entry.getValue().getClass();</span><br><span class="line"><span class="keyword">if</span>(!clazz.isAnnotationPresent(MyController.class))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拼url时,是controller头的url拼上方法上的url</span></span><br><span class="line">String baseUrl =<span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(clazz.isAnnotationPresent(MyRequestMapping.class))&#123;</span><br><span class="line">MyRequestMapping annotation = clazz.getAnnotation(MyRequestMapping.class);</span><br><span class="line">baseUrl=annotation.value();</span><br><span class="line">&#125;</span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="keyword">if</span>(!method.isAnnotationPresent(MyRequestMapping.class))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyRequestMapping annotation = method.getAnnotation(MyRequestMapping.class);</span><br><span class="line">String url = annotation.value();</span><br><span class="line">url =(baseUrl+<span class="string">"/"</span>+url).replaceAll(<span class="string">"/+"</span>, <span class="string">"/"</span>);</span><br><span class="line">handlerMapping.put(url,method);</span><br><span class="line">controllerMap.put(url,clazz.newInstance());</span><br><span class="line">System.out.println(url+<span class="string">","</span>+method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把字符串的首字母小写</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toLowerFirstWord</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] charArray = name.toCharArray();</span><br><span class="line">charArray[<span class="number">0</span>] += <span class="number">32</span>;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(charArray);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="8-这里我们就开发完了自己的SpringMVC，现在我们测试一下："><a href="#8-这里我们就开发完了自己的SpringMVC，现在我们测试一下：" class="headerlink" title="8.这里我们就开发完了自己的SpringMVC，现在我们测试一下："></a>8.这里我们就开发完了自己的SpringMVC，现在我们测试一下：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liugh.core.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liugh.annotation.MyController;</span><br><span class="line"><span class="keyword">import</span> com.liugh.annotation.MyRequestMapping;</span><br><span class="line"><span class="keyword">import</span> com.liugh.annotation.MyRequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyController</span></span><br><span class="line"><span class="meta">@MyRequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyRequestMapping</span>(<span class="string">"/doTest"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @MyRequestParam(<span class="string">"param"</span>)</span> String param)</span>&#123;</span><br><span class="line">System.out.println(param);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">response.getWriter().write( <span class="string">"doTest method success! param:"</span>+param);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyRequestMapping</span>(<span class="string">"/doTest2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">response.getWriter().println(<span class="string">"doTest2 method success!"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/liughMVC/test/doTest?param=liugh如下" target="_blank" rel="noopener">http://localhost:8080/liughMVC/test/doTest?param=liugh如下</a>:</p><blockquote><p>doTest method success!param:liugh</p></blockquote><p>访问一个不存在的试试：</p><blockquote><p>404 NOT FOUND!</p></blockquote><p>到这里我们就大功告成了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文转自liugh-develop&quot;&gt;&lt;a href=&quot;#本文转自liugh-develop&quot; class=&quot;headerlink&quot; title=&quot;本文转自liugh_develop&quot;&gt;&lt;/a&gt;本文转自&lt;a href=&quot;https://my.oschina.net/liughDevelop/blog/1622646&quot; title=&quot;liugh_develop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;liugh_develop&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;摘要: 前端框架很多,但没有一个框架称霸,后端框架现在Spring已经完成大一统.所以学习Spring是Java程序员的必修课.&lt;/p&gt;
&lt;p&gt;Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一个月的代码，最后还得其他老司机花3天时间重构，相信大部分老司机都很头疼看新手的代码。&lt;/p&gt;
&lt;p&gt;废话不多说，我们进入今天的正题，在Web应用程序设计中，MVC模式已经被广泛使用。SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。想要实现自己的SpringMVC框架，需要从以下几点入手：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/tags/Java/"/>
    
      <category term="SpringMVC" scheme="https://cq-harry.github.io/Harry.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java的接口和抽象类</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/17/深入理解Java的接口和抽象类/</id>
    <published>2018-03-17T10:23:17.000Z</published>
    <updated>2018-03-20T07:59:59.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文出处： <a href="http://www.cnblogs.com/dolphin0520/p/3811437.html" title="海 子" target="_blank" rel="noopener">海 子</a></p><p>对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。今天我们就一起来学习一下Java中的接口和抽象类。</p></blockquote><a id="more"></a><h3 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a><strong>一、抽象类</strong></h3><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。<strong>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。</strong><br><em>下面要注意一个问题：在《Java编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧，不必去深究为什么。</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看出，抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。<br>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><ul><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li><li>抽象类不能用来创建对象；</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li><li>在其他方面，抽象类和普通的类并没有区别。</li></ul><h3 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a><strong>二、接口</strong></h3><p>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。在Java中，定一个接口的形式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p><p>要让一个类遵循某组特地的接口需要使用implements关键字，具体格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1,Interface2,[....]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p><h3 id="三、抽象类和接口的区别"><a href="#三、抽象类和接口的区别" class="headerlink" title="三、抽象类和接口的区别"></a><strong>三、抽象类和接口的区别</strong></h3><h4 id="1-语法层面上的区别"><a href="#1-语法层面上的区别" class="headerlink" title="1.语法层面上的区别"></a>1.语法层面上的区别</h4><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li></ul><h4 id="2-设计层面上的区别"><a href="#2-设计层面上的区别" class="headerlink" title="2.设计层面上的区别"></a>2.设计层面上的区别</h4><ul><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</li><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li></ul><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p><ol><li>将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</li><li>将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li></ol><p>从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文出处： &lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3811437.html&quot; title=&quot;海 子&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;海 子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用，但是实际则不然。今天我们就一起来学习一下Java中的接口和抽象类。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/tags/Java/"/>
    
      <category term="接口" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="抽象类" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot自定义Banner</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/17/Spring-Boot%E8%87%AA%E5%AE%9A%E4%B9%89Banner/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/17/Spring-Boot自定义Banner/</id>
    <published>2018-03-17T08:42:00.000Z</published>
    <updated>2018-03-20T07:59:59.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在Spring Boot工程的<code>/src/main/resources</code>目录下创建一个<code>banner.txt</code>文件，然后将ASCII字符画复制进去，就能替换默认的banner了。比如上图中的输出，就采用了下面的<code>banner.txt</code>内容：</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_GREEN&#125;</span><br><span class="line">  _    _      _ _        __          __        _     _ </span><br><span class="line"> | |  | |    | | |       \ \        / /       | |   | |</span><br><span class="line"> | |__| | ___| | | ___    \ \  /\  / /__  _ __| | __| |</span><br><span class="line"> |  __  |/ _ \ | |/ _ \    \ \/  \/ / _ \| '__| |/ _` |</span><br><span class="line"> | |  | |  __/ | | (_) |    \  /\  / (_) | |  | | (_| |</span><br><span class="line"> |_|  |_|\___|_|_|\___/      \/  \/ \___/|_|  |_|\__,_|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;</span><br><span class="line">Application Version: $&#123;application.version&#125;$&#123;application.formatted-version&#125;</span><br><span class="line">Spring Boot Version: $&#123;spring-boot.version&#125;$&#123;spring-boot.formatted-version&#125;</span><br></pre></td></tr></table></figure><p><strong>从上面的内容中可以看到，还使用了一些属性设置：</strong></p><ul><li><code>${AnsiColor.BRIGHT_RED}</code>：设置控制台中输出内容的颜色</li><li><code>${application.version}</code>：用来获取<code>MANIFEST.MF</code>文件中的版本号</li><li><code>${application.formatted-version}</code>：格式化后的<code>${application.version}</code>版本信息</li><li><code>${spring-boot.version}</code>：Spring Boot的版本号</li><li><code>${spring-boot.formatted-version}</code>：格式化后的<code>${spring-boot.version}</code>版本信息</li></ul><h3 id="生成工具"><a href="#生成工具" class="headerlink" title="生成工具"></a>生成工具</h3><p>如果让我们手工的来编辑这些字符画，显然是一件非常困难的差事。所以，我们可以借助下面这些工具，轻松地根据文字或图片来生成用于Banner输出的字符画。</p><ul><li><a href="http://patorjk.com/software/taag" target="_blank" rel="noopener">http://patorjk.com/software/taag</a></li><li><a href="http://www.network-science.de/ascii/" target="_blank" rel="noopener">http://www.network-science.de/ascii/</a></li><li><a href="http://www.degraeve.com/img2txt.php" target="_blank" rel="noopener">http://www.degraeve.com/img2txt.php</a></li></ul><h3 id="奉上程序猿必备Banner-“永不宕机佛祖”！"><a href="#奉上程序猿必备Banner-“永不宕机佛祖”！" class="headerlink" title="奉上程序猿必备Banner “永不宕机佛祖”！"></a><strong>奉上程序猿必备Banner “永不宕机佛祖”！</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br><span class="line">//                          _ooOoo_                               //</span><br><span class="line">//                         o8888888o                              //</span><br><span class="line">//                         88&quot; . &quot;88                              //</span><br><span class="line">//                         (| ^_^ |)                              //</span><br><span class="line">//                         O\  =  /O                              //</span><br><span class="line">//                      ____/`---&apos;\____                           //</span><br><span class="line">//                    .&apos;  \\|     |//  `.                         //</span><br><span class="line">//                   /  \\|||  :  |||//  \                        //</span><br><span class="line">//                  /  _||||| -:- |||||-  \                       //</span><br><span class="line">//                  |   | \\\  -  /// |   |                       //</span><br><span class="line">//                  | \_|  &apos;&apos;\---/&apos;&apos;  |   |                       //</span><br><span class="line">//                  \  .-\__  `-`  ___/-. /                       //</span><br><span class="line">//                ___`. .&apos;  /--.--\  `. . ___                     //</span><br><span class="line">//              .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.                  //</span><br><span class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><br><span class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><br><span class="line">//      ========`-.____`-.___\_____/___.-`____.-&apos;========         //</span><br><span class="line">//                           `=---=&apos;                              //</span><br><span class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><br><span class="line">//            佛祖保佑       永不宕机     永无BUG                  //</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;在Spring Boot工程的&lt;code&gt;/src/main/resources&lt;/code&gt;目录下创建一个&lt;code&gt;banner.txt&lt;/code&gt;文件，然后将ASCII字符画复制进去，就能替换默认的banner了。比如上图中的输出，就采用了下面的&lt;code&gt;banner.txt&lt;/code&gt;内容：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://cq-harry.github.io/Harry.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://cq-harry.github.io/Harry.github.io/tags/Spring-Boot/"/>
    
      <category term="Banner" scheme="https://cq-harry.github.io/Harry.github.io/tags/Banner/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 常用注解</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/17/Spring-Boot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/17/Spring-Boot-常用注解/</id>
    <published>2018-03-17T04:19:57.000Z</published>
    <updated>2018-03-20T07:59:59.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Boot-常用注解"><a href="#Spring-Boot-常用注解" class="headerlink" title="Spring Boot 常用注解"></a>Spring Boot 常用注解</h3><ul><li><h4 id="SpringBootApplication："><a href="#SpringBootApplication：" class="headerlink" title="SpringBootApplication："></a><code>SpringBootApplication</code>：</h4><blockquote><p>包含<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code><br>通常用在主类上。</p></blockquote></li></ul><a id="more"></a><ul><li><h4 id="Repository："><a href="#Repository：" class="headerlink" title="Repository："></a><code>Repository</code>：</h4><blockquote><p>用于标注数据访问组件，即DAO组件。</p></blockquote></li><li><h4 id="Service："><a href="#Service：" class="headerlink" title="Service："></a><code>Service</code>：</h4><blockquote><p>用于标注业务层组件。</p></blockquote></li><li><h4 id="RestController："><a href="#RestController：" class="headerlink" title="RestController："></a><code>RestController</code>：</h4><blockquote><p>用于标注控制层组件(如struts中的action)，包含<code>@Controller</code>和<code>@ResponseBody</code>。</p></blockquote></li><li><h4 id="ResponseBody："><a href="#ResponseBody：" class="headerlink" title="ResponseBody："></a><code>ResponseBody</code>：</h4><blockquote><p>表示该方法的返回结果直接写入HTTP response body中。<br>一般在异步获取数据时使用，在使用<code>@RequestMapping</code>后，返回值通常解析为跳转路径，加上<code>@responsebody</code>后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上<code>@responsebody</code>后，会直接返回json数据。</p></blockquote></li><li><h4 id="Component："><a href="#Component：" class="headerlink" title="Component："></a><code>Component</code>：</h4><blockquote><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p></blockquote></li><li><h4 id="ComponentScan："><a href="#ComponentScan：" class="headerlink" title="ComponentScan："></a><code>ComponentScan</code>：</h4><blockquote><p>组件扫描。如果扫描到有<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>等这些注解的类，则把这些类注册为bean。</p></blockquote></li><li><h4 id="Configuration："><a href="#Configuration：" class="headerlink" title="Configuration："></a><code>Configuration</code>：</h4><blockquote><p>指出该类是 Bean 配置的信息源，相当于XML中的<code>&lt;beans&gt;&lt;/beans&gt;</code>，一般加在主类上。</p></blockquote></li><li><h4 id="Bean"><a href="#Bean" class="headerlink" title="Bean:"></a><code>Bean</code>:</h4><blockquote><p>相当于XML中的<code>&lt;bean&gt;&lt;/bean&gt;</code>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p></blockquote></li><li><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="EnableAutoConfiguration:"></a><code>EnableAutoConfiguration</code>:</h4><blockquote><p>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。</p></blockquote></li><li><h4 id="AutoWired"><a href="#AutoWired" class="headerlink" title="AutoWired:"></a><code>AutoWired</code>:</h4><blockquote><p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。<br>当加上（required=false）时，就算找不到bean也不报错。</p></blockquote></li><li><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="Qualifier:"></a><code>Qualifier</code>:</h4><blockquote><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p></blockquote></li><li><h4 id="Resource-name-quot-name-quot-type-quot-type-quot"><a href="#Resource-name-quot-name-quot-type-quot-type-quot" class="headerlink" title="Resource(name=&quot;name&quot;,type=&quot;type&quot;):"></a><code>Resource(name=&quot;name&quot;,type=&quot;type&quot;)</code>:</h4><blockquote><p>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p></blockquote></li><li><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping:"></a><code>RequestMapping</code>:</h4><blockquote><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p></blockquote></li><li><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam:"></a><code>RequestParam</code>:</h4><blockquote><p>用在方法的参数前面。<br><code>@RequestParam String a =request.getParameter(&quot;a&quot;)</code></p></blockquote></li><li><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable:"></a><code>PathVariable</code>:</h4><blockquote><p>路径变量。参数与大括号里的名字一样要相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">"user/get/mac/&#123;macAddress&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getByMacAddress</span><span class="params">(@PathVariable String macAddress)</span></span>&#123;</span><br><span class="line">　　<span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles:"></a><code>Profiles</code>:</h4><blockquote><p>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。<br>任何<code>@Component</code>或<code>@Configuration</code>都能被<code>@Profile</code>标记，从而限制加载它的时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="ConfigurationProperties:"></a><code>ConfigurationProperties</code>:</h4><blockquote><p>Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。<br>你可以轻松的为你的<code>@ConfigurationProperties</code>类添加JSR-303 javax.validation约束注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"connection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"><span class="comment">// ... getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring-Boot-常用注解&quot;&gt;&lt;a href=&quot;#Spring-Boot-常用注解&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 常用注解&quot;&gt;&lt;/a&gt;Spring Boot 常用注解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;SpringBootApplication：&quot;&gt;&lt;a href=&quot;#SpringBootApplication：&quot; class=&quot;headerlink&quot; title=&quot;SpringBootApplication：&quot;&gt;&lt;/a&gt;&lt;code&gt;SpringBootApplication&lt;/code&gt;：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;包含&lt;code&gt;@Configuration&lt;/code&gt;、&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;、&lt;code&gt;@ComponentScan&lt;/code&gt;&lt;br&gt;通常用在主类上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://cq-harry.github.io/Harry.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://cq-harry.github.io/Harry.github.io/tags/Spring-Boot/"/>
    
      <category term="注解" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 微服务实战（三）</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/17/Spring-Cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/17/Spring-Cloud-微服务实战（三）/</id>
    <published>2018-03-17T04:00:38.000Z</published>
    <updated>2018-03-20T07:59:59.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端负载均衡：Spring-Cloud-Ribbon"><a href="#客户端负载均衡：Spring-Cloud-Ribbon" class="headerlink" title="客户端负载均衡：Spring Cloud Ribbon"></a>客户端负载均衡：Spring Cloud Ribbon</h3><blockquote><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud 的封装，可以将面向服务的REST模板请求自动转化成客户端负载均衡的服务调用。Spring Cloud Ribbon虽然只是一个工具类框架，不像服务注册中心、配置中心、API网关需要独立部署，它几乎存在于每一个Spring Cloud 构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon实现。</p></blockquote><a id="more"></a><h4 id="1-客户端负载均衡"><a href="#1-客户端负载均衡" class="headerlink" title="1. 客户端负载均衡"></a>1. 客户端负载均衡</h4><blockquote><p>负载均衡在系统架构中是一个非常重要，并且是不得不去实施的内容。因为负载均衡是对系统的高可用、网络压力的缓解和处理能力扩容的重要手段之一。常说的负载均衡指服务端负载均衡，分为硬件负载均衡(在服务器节点之间安装专门用于负载均衡的设备)和软件负载均衡（Nginx等）。<br>客户端负载均衡和服务端负载均衡最大的不同点：服务清单所存储的位置。客服端负载均衡中，所有客户端节点都维护着自己要访问的来自服务注册中心的服务端清单。<br>用Spring Boot Ribbon在微服务调用方法：①服务提供者启动多个服务实例并注册到一个注册中心或者多个相关联的服务注册中心、②服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate实现面向服务的接口调用。</p></blockquote><h4 id="2-RestTemplate详解"><a href="#2-RestTemplate详解" class="headerlink" title="2. RestTemplate详解"></a>2. RestTemplate详解</h4><h5 id="2-1-GET请求"><a href="#2-1-GET请求" class="headerlink" title="2.1 GET请求"></a>2.1 GET请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的ResponseEntity对象中body返回String类型</span></span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/user?name=&#123;1&#125;"</span>,String.class,<span class="string">"didi"</span>);</span><br><span class="line">String body = responseEntity.getBody();</span><br><span class="line"><span class="comment">//返回的ResponseEntity对象中body返回User类型</span></span><br><span class="line">ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/user?name=&#123;1&#125;"</span>,User.class,<span class="string">"didi"</span>);</span><br><span class="line">User body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><h6 id="2-1-1-getForEntity三种不同的重载实现："><a href="#2-1-1-getForEntity三种不同的重载实现：" class="headerlink" title="2.1.1 getForEntity三种不同的重载实现："></a>2.1.1 getForEntity三种不同的重载实现：</h6><ul><li>getForEntity(String url, Class<t> responseType, Object… uriVariables)</t></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/user?name=&#123;1&#125;"</span>,String.class,<span class="string">"didi"</span>);</span><br></pre></td></tr></table></figure><ul><li>getForEntity(String url, Class<t> responseType, Map&lt;String, ?&gt; uriVariables)</t></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">params.put(<span class="string">"name"</span>,<span class="string">"didi"</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/user?name=&#123;name&#125;"</span>,String.class,params);</span><br></pre></td></tr></table></figure><ul><li>getForEntity(URI url, Class<t> responseType)</t></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://USER-SERVICE/user?name=&#123;name&#125;"</span>).build().expand(<span class="string">"dodo"</span>).encode();</span><br><span class="line">URI uri = uriComponents.toUri();</span><br><span class="line">restTemplate.getForEntity(uri,String.class);</span><br></pre></td></tr></table></figure><h6 id="2-1-2-getForObject三种不同的重载实现："><a href="#2-1-2-getForObject三种不同的重载实现：" class="headerlink" title="2.1.2 getForObject三种不同的重载实现："></a>2.1.2 getForObject三种不同的重载实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://USER-SERVICE/user?name=&#123;name&#125;"</span>).build().expand(<span class="string">"dodo"</span>).encode();</span><br><span class="line">URI uri = uriComponents.toUri();</span><br><span class="line"><span class="comment">//body是String</span></span><br><span class="line">String uesult = restTemplate.getForObject(uri,String.class);</span><br><span class="line"><span class="comment">//body是一个User对象</span></span><br><span class="line">User uesult = restTemplate.getForObject(uri,User.class);</span><br></pre></td></tr></table></figure><ul><li>getForObject(String url, Class<t> responseType, Object… uriVariables)</t></li><li>getForObject(String url, Class<t> responseType, Map&lt;String, ?&gt; uriVariables)</t></li><li>getForObject(URI url, Class<t> responseType)</t></li></ul><h5 id="2-2-POST请求"><a href="#2-2-POST请求" class="headerlink" title="2.2 POST请求"></a>2.2 POST请求</h5><blockquote><p>相比较GET请求新增request参数，可以是一个普通对象，也可以是一个HttpEntity对象。如果是一个普通对象，RestTemplate会将请求对象转换为一个HttpEntity对象来处理，request内容会被视为完整的body处理；而如果request是一个HttpEntity对象，就会被当作一个完整的HTTP请求处理，包含body内容、header内容。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"didi"</span>,<span class="number">30</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(<span class="string">"http://USER-SERVICE/user"</span>,user,String.class);</span><br></pre></td></tr></table></figure><h6 id="2-2-1-getForEntity三种不同的重载实现："><a href="#2-2-1-getForEntity三种不同的重载实现：" class="headerlink" title="2.2.1 getForEntity三种不同的重载实现："></a>2.2.1 getForEntity三种不同的重载实现：</h6><ul><li>postForEntity(String url, Object request, Class<t> responseType, Object… uriVariables)</t></li><li>postForEntity(String url, Object request, Class<t> responseType, Map&lt;String, ?&gt; uriVariables)</t></li><li>postForEntity(URI url, Object request, Class<t> responseType)</t></li></ul><h6 id="2-2-2-getForObject三种不同的重载实现："><a href="#2-2-2-getForObject三种不同的重载实现：" class="headerlink" title="2.2.2 getForObject三种不同的重载实现："></a>2.2.2 getForObject三种不同的重载实现：</h6><ul><li>postForObject(String url, Object request, Class<t> responseType, Object… uriVariables)</t></li><li>postForObject(String url, Object request, Class<t> responseType, Map&lt;String, ?&gt; uriVariables)</t></li><li>postForObject(URI url, Object request, Class<t> responseType)</t></li></ul><h6 id="2-2-3-postForLocation三种不同的重载实现："><a href="#2-2-3-postForLocation三种不同的重载实现：" class="headerlink" title="2.2.3 postForLocation三种不同的重载实现："></a>2.2.3 postForLocation三种不同的重载实现：</h6><ul><li>postForLocation(String url, Object request, Object… uriVariables)</li><li>postForLocation(String url, Object request, Map&lt;String, ?&gt; uriVariables)</li><li>postForLocation(URI url, Object request)</li></ul><h5 id="2-3-PUT请求"><a href="#2-3-PUT请求" class="headerlink" title="2.3 PUT请求"></a>2.3 PUT请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long id = <span class="number">10001L</span>;</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"didi"</span>,<span class="number">40</span>);</span><br><span class="line">restTemplate.put(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,user,id);</span><br></pre></td></tr></table></figure><p><strong>put三种不同的重载实现：</strong></p><ul><li>put(String url, Object request, Object… uriVariables)</li><li>put(String url, Object request, Map&lt;String, ?&gt; uriVariables)</li><li>put(URI url, Object request)</li></ul><h5 id="2-4-DELETE请求"><a href="#2-4-DELETE请求" class="headerlink" title="2.4 DELETE请求"></a>2.4 DELETE请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long id = <span class="number">10001L</span>;</span><br><span class="line">restTemplate.delete(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,id);</span><br></pre></td></tr></table></figure><p><strong>delete三种不同的重载实现：</strong></p><ul><li>delete(String url, Object… uriVariables)</li><li>delete(String url, Map&lt;String, ?&gt; uriVariables)</li><li>delete(URI url)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;客户端负载均衡：Spring-Cloud-Ribbon&quot;&gt;&lt;a href=&quot;#客户端负载均衡：Spring-Cloud-Ribbon&quot; class=&quot;headerlink&quot; title=&quot;客户端负载均衡：Spring Cloud Ribbon&quot;&gt;&lt;/a&gt;客户端负载均衡：Spring Cloud Ribbon&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud 的封装，可以将面向服务的REST模板请求自动转化成客户端负载均衡的服务调用。Spring Cloud Ribbon虽然只是一个工具类框架，不像服务注册中心、配置中心、API网关需要独立部署，它几乎存在于每一个Spring Cloud 构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="https://cq-harry.github.io/Harry.github.io/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://cq-harry.github.io/Harry.github.io/tags/Spring-Cloud/"/>
    
      <category term="微服务" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Ribbon" scheme="https://cq-harry.github.io/Harry.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>阿里云Redis开发规范</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/16/%E9%98%BF%E9%87%8C%E4%BA%91Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/16/阿里云Redis开发规范/</id>
    <published>2018-03-16T04:05:44.000Z</published>
    <updated>2018-03-16T07:48:19.174Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要： 本文介绍了在使用阿里云Redis的开发规范，从键值设计、命令使用、客户端使用、相关工具等方面进行说明，通过本文的介绍可以减少使用Redis过程带来的问题。</p></blockquote><a id="more"></a><h3 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h3><h4 id="1-key名设计"><a href="#1-key名设计" class="headerlink" title="1. key名设计"></a>1. key名设计</h4><p>(1)【建议】: 可读性和可管理性<br>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><pre><code>ugc:video:1</code></pre><p>(2)【建议】：简洁性<br>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><pre><code>user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。</code></pre><p>(3)【强制】：不要包含特殊字符<br>反例：包含空格、换行、单双引号以及其他转义字符</p><h4 id="2-value设计"><a href="#2-value设计" class="headerlink" title="2. value设计"></a>2. value设计</h4><p>(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)<br>string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p><p>(2)【推荐】：选择适合的数据类型。<br>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)<br>反例：</p><pre><code>set user:1:name tomset user:1:age 19set user:1:favor football</code></pre><p>正例:</p><pre><code>hmset user:1 name tom age 19 favor football</code></pre><h4 id="3-【推荐】：控制key的生命周期，redis不是垃圾桶。"><a href="#3-【推荐】：控制key的生命周期，redis不是垃圾桶。" class="headerlink" title="3.【推荐】：控制key的生命周期，redis不是垃圾桶。"></a>3.【推荐】：控制key的生命周期，redis不是垃圾桶。</h4><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p><h3 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h3><h4 id="1-【推荐】-O-N-命令关注N的数量"><a href="#1-【推荐】-O-N-命令关注N的数量" class="headerlink" title="1.【推荐】 O(N)命令关注N的数量"></a>1.【推荐】 O(N)命令关注N的数量</h4><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><h4 id="2-【推荐】：禁用命令"><a href="#2-【推荐】：禁用命令" class="headerlink" title="2.【推荐】：禁用命令"></a>2.【推荐】：禁用命令</h4><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><h4 id="3-【推荐】合理使用select"><a href="#3-【推荐】合理使用select" class="headerlink" title="3.【推荐】合理使用select"></a>3.【推荐】合理使用select</h4><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><h4 id="4-【推荐】使用批量操作提高效率"><a href="#4-【推荐】使用批量操作提高效率" class="headerlink" title="4.【推荐】使用批量操作提高效率"></a>4.【推荐】使用批量操作提高效率</h4><pre><code>原生命令：例如mget、mset。非原生命令：可以使用pipeline提高效率。</code></pre><p>但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。<br>注意两者不同：</p><pre><code>1. 原生是原子操作，pipeline是非原子操作。2. pipeline可以打包不同的命令，原生做不到3. pipeline需要客户端和服务端同时支持。</code></pre><h4 id="5-【建议】Redis事务功能较弱，不建议过多使用"><a href="#5-【建议】Redis事务功能较弱，不建议过多使用" class="headerlink" title="5.【建议】Redis事务功能较弱，不建议过多使用"></a>5.【建议】Redis事务功能较弱，不建议过多使用</h4><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p><h4 id="6-【建议】Redis集群版本在使用Lua上有特殊要求："><a href="#6-【建议】Redis集群版本在使用Lua上有特殊要求：" class="headerlink" title="6.【建议】Redis集群版本在使用Lua上有特殊要求："></a>6.【建议】Redis集群版本在使用Lua上有特殊要求：</h4><ul><li>所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array”</li><li>所有key，必须在1个slot上，否则直接返回error, “-ERR eval/evalsha command keys must in same slot”</li></ul><h4 id="7-【建议】必要情况下使用monitor命令时，要注意不要长时间使用。"><a href="#7-【建议】必要情况下使用monitor命令时，要注意不要长时间使用。" class="headerlink" title="7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。"></a>7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。</h4><h3 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h3><h4 id="1-【推荐】"><a href="#1-【推荐】" class="headerlink" title="1.【推荐】"></a>1.【推荐】</h4><p>避免多个应用使用一个Redis实例<br><br>正例：不相干的业务拆分，公共数据做服务化。</p><h4 id="2-【推荐】"><a href="#2-【推荐】" class="headerlink" title="2.【推荐】"></a>2.【推荐】</h4><p>使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行命令如下：</span></span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//具体的命令</span></span><br><span class="line">    jedis.executeCommand()</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">"op key &#123;&#125; error: "</span> + e.getMessage(), key, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) </span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是JedisPool优化方法的文章:</p><ul><li><a href="https://yq.aliyun.com/articles/236384?spm=a2c4e.11153959.blogcont531067.13.fdaf45b5wCuHod" target="_blank" rel="noopener">Jedis常见异常汇总</a></li><li><a href="https://yq.aliyun.com/articles/236383?spm=a2c4e.11153959.blogcont531067.14.fdaf45b5wCuHod" target="_blank" rel="noopener">JedisPool资源池优化</a></li></ul><h4 id="3-【建议】"><a href="#3-【建议】" class="headerlink" title="3.【建议】"></a>3.【建议】</h4><p>高并发下建议客户端添加熔断功能(例如netflix hystrix)</p><h4 id="4-【推荐】"><a href="#4-【推荐】" class="headerlink" title="4.【推荐】"></a>4.【推荐】</h4><p>设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p><h4 id="5-【建议】"><a href="#5-【建议】" class="headerlink" title="5.【建议】"></a>5.【建议】</h4><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。<br>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。<br>其他策略如下：</p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random:随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li></ul><h3 id="四、相关工具"><a href="#四、相关工具" class="headerlink" title="四、相关工具"></a>四、相关工具</h3><h4 id="1-【推荐】：数据同步"><a href="#1-【推荐】：数据同步" class="headerlink" title="1.【推荐】：数据同步"></a>1.【推荐】：数据同步</h4><p>redis间数据同步可以使用：redis-port</p><h4 id="2-【推荐】：big-key搜索"><a href="#2-【推荐】：big-key搜索" class="headerlink" title="2.【推荐】：big key搜索"></a>2.【推荐】：big key搜索</h4><p><a href="https://yq.aliyun.com/articles/117042?spm=a2c4e.11153959.blogcont531067.15.fdaf45b5wCuHod" target="_blank" rel="noopener">redis大key搜索工具</a></p><h4 id="3-【推荐】：热点key寻找-内部实现使用monitor，所以建议短时间使用"><a href="#3-【推荐】：热点key寻找-内部实现使用monitor，所以建议短时间使用" class="headerlink" title="3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)"></a>3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)</h4><p><a href="https://github.com/facebookarchive/redis-faina?spm=a2c4e.11153959.blogcont531067.16.fdaf45b5wCuHod" target="_blank" rel="noopener">facebook的redis-faina</a></p><pre><code>阿里云Redis已经在内核层面解决热点key问题，欢迎使用。</code></pre><h3 id="五-附录：删除bigkey"><a href="#五-附录：删除bigkey" class="headerlink" title="五 附录：删除bigkey"></a>五 附录：删除bigkey</h3><pre><code>1. 下面操作可以使用pipeline加速。2. redis 4.0已经支持key的异步删除，欢迎使用。</code></pre><h4 id="1-Hash删除-hscan-hdel"><a href="#1-Hash删除-hscan-hdel" class="headerlink" title="1. Hash删除: hscan + hdel"></a>1. Hash删除: hscan + hdel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigHash</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigHashKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Entry&lt;String, String&gt;&gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);</span><br><span class="line">        List&lt;Entry&lt;String, String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (entryList != <span class="keyword">null</span> &amp;&amp; !entryList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey, entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-List删除-ltrim"><a href="#2-List删除-ltrim" class="headerlink" title="2. List删除: ltrim"></a>2. List删除: ltrim</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigList</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigListKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> llen = jedis.llen(bigListKey);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter &lt; llen) &#123;</span><br><span class="line">        <span class="comment">//每次从左侧截掉100个</span></span><br><span class="line">        jedis.ltrim(bigListKey, left, llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终删除key</span></span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Set删除-sscan-srem"><a href="#3-Set删除-sscan-srem" class="headerlink" title="3. Set删除: sscan + srem"></a>3. Set删除: sscan + srem</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigSet</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigSetKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (memberList != <span class="keyword">null</span> &amp;&amp; !memberList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String member : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey, member);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-SortedSet删除-zscan-zrem"><a href="#4-SortedSet删除-zscan-zrem" class="headerlink" title="4. SortedSet删除: zscan + zrem"></a>4. SortedSet删除: zscan + zrem</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigZset</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigZsetKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (tupleList != <span class="keyword">null</span> &amp;&amp; !tupleList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey, tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要： 本文介绍了在使用阿里云Redis的开发规范，从键值设计、命令使用、客户端使用、相关工具等方面进行说明，通过本文的介绍可以减少使用Redis过程带来的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://cq-harry.github.io/Harry.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://cq-harry.github.io/Harry.github.io/tags/Redis/"/>
    
      <category term="阿里云Redis" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91Redis/"/>
    
      <category term="Redis规范" scheme="https://cq-harry.github.io/Harry.github.io/tags/Redis%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 微服务实战（二）</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Spring-Cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Spring-Cloud-微服务实战（二）/</id>
    <published>2018-03-15T15:10:41.000Z</published>
    <updated>2018-03-16T09:12:05.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务治理：Spring-Cloud-Eureka"><a href="#服务治理：Spring-Cloud-Eureka" class="headerlink" title="服务治理：Spring Cloud Eureka"></a>服务治理：Spring Cloud Eureka</h1><blockquote><p>该模块主要负责完成微服务架构中的服务治理功能。主要用来实现各个微服务实例的自动化注册于发现。</p><ul><li>服务注册：<br>在服务治理框架中，通常都会构建一个注册中心，每个服务单元想注册中心登记自己提供的服务，将主机与端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。</li><li>服务发现：由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问。</li></ul></blockquote><a id="more"></a><h2 id="1-搭建服务注册中心"><a href="#1-搭建服务注册中心" class="headerlink" title="1.搭建服务注册中心"></a>1.搭建服务注册中心</h2><p>(1)新建Spring Boot项目，pom.xml中引入必要的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)通过@EnableEurekaClient注解启动一个服务注册中心提供给其他应用进行对话。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springclouddemo2Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)application.properties添加配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.hostname=localhost</span><br><span class="line"># 不向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"># 由于注册中心的职责就是维护服务实例，不需要去检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></pre></td></tr></table></figure></p><p>(4)启动并访问<a href="http://localhost:1111/" target="_blank" rel="noopener">http://localhost:1111/</a> 可以看到Eureka信息面板。</p><h2 id="2-注册服务提供者"><a href="#2-注册服务提供者" class="headerlink" title="2.注册服务提供者"></a>2.注册服务提供者</h2><p>(1)新建Spring Boot项目，pom.xml中引入必要的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)新增HelloController<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(getClass());</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceInstance instance = discoveryClient.getLocalServiceInstance();</span><br><span class="line">        logger.info(<span class="string">"/hello,host:"</span> + instance.getHost() + <span class="string">",service_id:"</span> + instance.getServiceId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)在主类中通过加上@EnableEurekaClient注解，激活Eureka中的DiscoveryClient实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springclouddemo2Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springclouddemo2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(4)application.properties添加配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=hello-service</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</span><br></pre></td></tr></table></figure></p><p><strong>(5)分别启动1.2.项目，在2项目的控制台<code>com.netflix.discovery.DiscouveryClient</code>对象打印了该服务的注册信息，表示注册成功。而此时在1项目控制台输出：名为hello-service的服务被注册成功了。</strong></p><h2 id="3-高可用注册中心"><a href="#3-高可用注册中心" class="headerlink" title="3.高可用注册中心"></a>3.高可用注册中心</h2><blockquote><p>Eureka Server的高可用实际上就是将自己作为服务项其他服务注册中心注册自己，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。在项目1基础上进行扩展，构建一个双节点的服务注册中心集群。</p></blockquote><p>(1)创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=eureka-server</span><br><span class="line">server.port=1111</span><br><span class="line">eureka.instance.hostname=peer1</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/</span><br></pre></td></tr></table></figure><p><strong>(2)创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=eureka-server</span><br><span class="line">server.port=1112</span><br><span class="line">eureka.instance.hostname=peer2</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/</span><br></pre></td></tr></table></figure></p><p><strong>(3)在hosts文件中添加对peer1和peer2的转换，让上面配置的host形式的serviceUrl能在本地正确访问到；</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1peer1</span><br><span class="line">127.0.0.1peer2</span><br></pre></td></tr></table></figure></p><p><strong>(4)通过spring.profiles.active属性来分别启动peer1和peer2：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure></p><p>此时访问peer1的注册中心<a href="http://localhost:1111/" target="_blank" rel="noopener">http://localhost:1111/</a> ，可以看到registered-replicas中已经有peer2节点的eureka-server了。同样的，访问peer2的注册中心<a href="http://localhost:1112/" target="_blank" rel="noopener">http://localhost:1112/</a> ，也能看到registered-replicas中已经有peer1节点。<br><strong>·在设置了多节点的服务注册中心之后，服务提供方还需要配置才能将服务注册到Eureka Server集群中。修改项目2的application.properties配置文件：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=hello-service</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/</span><br></pre></td></tr></table></figure></p><p>启动该项目，访问<a href="http://localhost:1111/" target="_blank" rel="noopener">http://localhost:1111/</a> 和 <a href="http://localhost:1112/" target="_blank" rel="noopener">http://localhost:1112/</a> ,可以看到hello-server服务同时注册到peer1和peer2上。若此时断开peer1，由于同时也像peer2注册，因此在peer2上的服务依然能访问到hello-server，从而实现了服务注册中心的高可用。</p><h2 id="4-服务发现与消费"><a href="#4-服务发现与消费" class="headerlink" title="4.服务发现与消费"></a>4.服务发现与消费</h2><blockquote><p>前3点已经有了服务注册中心和服务提供者，现在构建一个服务消费者，主要完成两个目标，发现服务以及消费服务。服务发现的任务由Eureka的客户端完成，服务消费的任务由Ribbon完成。</p></blockquote><p><strong>(1)启动项目2：hello-service服务，实验Ribbon的客户端负载均衡功能，使用java -jar命令行的方式来启动两个不同端口的hello-service，如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello-service-0.0.1-SNAPSHOT.jar --server.port=8081</span><br><span class="line">java -jar hello-service-0.0.1-SNAPSHOT.jar --server.port=8082</span><br></pre></td></tr></table></figure><p><strong>(2)启动成功后，从Eureka信息面板可以看到名为HELLO-SERVICE的服务中出现了两个实例单元，分别是通过8081端口和8082端口的服务。</strong><br><strong>(3)创建Spring Boot的基础工程来实现服务消费者（ribbon-consumer），在pom.xml引入如下依赖：</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>(4)在应用启动主类通过@EnableDiscoveryClient注解让该应用注册为Eureka客户端应用，以获得服务发现的能力。同时在该主类中创建RestTemplate的Spring Bean实例，并通过@LoadBalanced注解开启客户端负载均衡。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RibbonConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(5)创建ConsumerController类并实现/ribbon-consumer接口。在该接口中，通过在上面创建的RestTemplate来实现对HELLO-SERVICE服务提供的/hello接口进行调用。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/ribbon-consumer"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://HELLO-SERVICE/hello"</span>, String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(6)在application.properties中配置Eureka服务注册中心的位置，需要与之前的HELLO-SERVER一样，不然是发现不了该服务的，同时设置该消费者的端口为9000，否则会冲突。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=ribbon-consumer</span><br><span class="line">server.port=9000</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</span><br></pre></td></tr></table></figure></p><p><strong>启动ribbon-consumer应用后，在Eureka信息面板中看到除了HELLO-SERVER之外，还有RIBBON-CONSUMER服务。</strong><br><strong>访问http：//localhost:9000/ribbon-consumer 发起GET请求，返回“Hello World”。在ribbon-consumer控制台看到Ribbon输出了当前客户端维护的HELLO-SERVICE的服务列表情况。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;服务治理：Spring-Cloud-Eureka&quot;&gt;&lt;a href=&quot;#服务治理：Spring-Cloud-Eureka&quot; class=&quot;headerlink&quot; title=&quot;服务治理：Spring Cloud Eureka&quot;&gt;&lt;/a&gt;服务治理：Spring Cloud Eureka&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该模块主要负责完成微服务架构中的服务治理功能。主要用来实现各个微服务实例的自动化注册于发现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务注册：&lt;br&gt;在服务治理框架中，通常都会构建一个注册中心，每个服务单元想注册中心登记自己提供的服务，将主机与端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。&lt;/li&gt;
&lt;li&gt;服务发现：由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="https://cq-harry.github.io/Harry.github.io/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://cq-harry.github.io/Harry.github.io/tags/Spring-Cloud/"/>
    
      <category term="微服务" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Eureka" scheme="https://cq-harry.github.io/Harry.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 微服务实战（一）</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Spring-Cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Spring-Cloud-微服务实战（一）/</id>
    <published>2018-03-15T15:07:28.000Z</published>
    <updated>2018-03-16T09:14:49.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-actuator"><a href="#SpringBoot-actuator" class="headerlink" title="SpringBoot-actuator"></a>SpringBoot-actuator</h1><blockquote><p>该模块能够自动为Spring Boot 构建的应用提供一系列用于监控的端点。同时，Spring Cloud 在实现各个微服务组件的时候，进一步为该模块做了不少扩展，比如，为原生端点增加了更多的指标和度量信息。</p></blockquote><a id="more"></a><h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h2><blockquote><p>在pom.xml的dependencies节点中新增spring-boot-starter-actuator的依赖即可：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="2-application-properties添加配置参数"><a href="#2-application-properties添加配置参数" class="headerlink" title="2.application.properties添加配置参数"></a>2.application.properties添加配置参数</h2><blockquote><p>访问/beans 等敏感的信息时候报错401<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.security.enabled=false</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="3-端点解析"><a href="#3-端点解析" class="headerlink" title="3.端点解析"></a>3.端点解析</h2><blockquote><p>分为3大类：应用配置类（autoconfig、beans、configprops、env、mappings、info）、度量指标类（metrics、health、dump、trace）、操作控制类（shutdown）</p></blockquote><table><thead><tr><th style="text-align:left">ID</th><th style="text-align:left">描述</th><th style="text-align:left">敏感</th></tr></thead><tbody><tr><td style="text-align:left">autoconfig</td><td style="text-align:left">获取应用的自动化配置报告，其中包括所有自动化配置的候选项。同事还列出了每个候选项是否满足自动化配置的各个先决条件。所以，该端点可以帮助我们方便地找到一些自动化配置为什么没有生效的具体原因。该报告内容将自动化配置内容分为两部分：positiveMatches中返回的是条件匹配成功的自动化配置、negativeMatches中返回的是条件匹配不成功的自动化配置</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">beans</td><td style="text-align:left">获取应用上下文中创建的所有 Bean，每个 Bean 中包含：bean（Bean的名称）、scope（Bean的作用域）、type（Bean的Java类型）、resource（class文件的具体路径）、dependencies（依赖的Bean名称）</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">configprops</td><td style="text-align:left">获取应用中配置的属性信息报告（关闭该端点，使用endpoints.configprops.enabled=false来完成设置）</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">env</td><td style="text-align:left">获取应用所有可用的环境属性报告。包括环境变量、JVM属性、应用的配置属性、命令行中参数。为了配置属性的安全，对于一些类似密码等敏感信息，该端点都会进行隐私保护，但是需要让属性名中包含password、secret、key这些关键字，这样该端点在返回它们的时候会使用*来替代实际的属性值。</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">mappings</td><td style="text-align:left">返回所有Spring MVC的控制器映射关系报告。其中bean属性标识了该映射关系的请求处理器，method属性标识了该映射关系的具体处理类和处理函数。</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">info</td><td style="text-align:left">返回一些应用自定义的信息。默认该端点只会返回一个空的JSON内容。可以在application.properties配置文件通过info前缀来设置一些属性。</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">metrics</td><td style="text-align:left">返回当前应用的各类重要度量指标，比如内存信息、线程信息、垃圾回收信息等。还可以通过/metrics/{name}接口来更细粒度地获取度量信息。</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">health</td><td style="text-align:left">获取应用的各类健康指标信息。</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">dump</td><td style="text-align:left">用来暴露程序运行中的线程信息。</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">trace</td><td style="text-align:left">返回基本的HTTP跟踪信息。默认跟踪信息的存储采用org.springframework.boot.actuate.trace.InMemoryTraceRepository实现的内存方式，始终保留最近的100条请求记录。</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">shutdown</td><td style="text-align:left">实现关闭该应用的远程操作。通过配置来开启：endpoints.shutdown.enabled=true</td><td style="text-align:left">true</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-actuator&quot;&gt;&lt;a href=&quot;#SpringBoot-actuator&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-actuator&quot;&gt;&lt;/a&gt;SpringBoot-actuator&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该模块能够自动为Spring Boot 构建的应用提供一系列用于监控的端点。同时，Spring Cloud 在实现各个微服务组件的时候，进一步为该模块做了不少扩展，比如，为原生端点增加了更多的指标和度量信息。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="https://cq-harry.github.io/Harry.github.io/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://cq-harry.github.io/Harry.github.io/tags/Spring-Cloud/"/>
    
      <category term="微服务" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="actuator" scheme="https://cq-harry.github.io/Harry.github.io/tags/actuator/"/>
    
  </entry>
  
  <entry>
    <title>Java排序算法整理</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Java排序算法整理/</id>
    <published>2018-03-15T15:05:14.000Z</published>
    <updated>2018-03-16T09:17:47.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-冒泡排序法："><a href="#1-冒泡排序法：" class="headerlink" title="1.冒泡排序法："></a>1.冒泡排序法：</h4><a id="more"></a><blockquote><p>专门针对已部分排序的数据进行排序。如果在你的数据清单中只有一两个数据是乱序的，用这种算法就是最快的排序算法。如果你的数据清单中的数据是随机排列的，那么这种方法就有可能是最慢的算法。</p><p>该算法的核心思想是扫描数据清单。寻找出现乱序的两个相邻的项目，当找到这两个项目后，交换项目的位置然后继续扫描。重复上面的操作直到所有的项目都按照顺序排好。<br><strong>举个栗子：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.println(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>……</p><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-冒泡排序法：&quot;&gt;&lt;a href=&quot;#1-冒泡排序法：&quot; class=&quot;headerlink&quot; title=&quot;1.冒泡排序法：&quot;&gt;&lt;/a&gt;1.冒泡排序法：&lt;/h4&gt;
    
    </summary>
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/tags/Java/"/>
    
      <category term="排序算法" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典Java面试题整理</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/%E7%BB%8F%E5%85%B8Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/经典Java面试题整理/</id>
    <published>2018-03-15T15:02:38.000Z</published>
    <updated>2018-03-16T09:25:13.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-面向对象编程（OOP）"><a href="#1-面向对象编程（OOP）" class="headerlink" title="1.面向对象编程（OOP）"></a>1.面向对象编程（OOP）</h4><blockquote><p>Java是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：</p><ol><li>代码开发模块化，更易维护和修改。</li><li>代码复用。</li><li>增强代码的可靠性和灵活性。</li><li>增加代码的可理解性。</li><li>面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象</li></ol></blockquote><a id="more"></a><h4 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h4><blockquote><p>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处:</p><ol><li>通过隐藏对象的属性来保护对象内部的状态。</li><li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li><li>禁止对象之间的不良交互提高模块化。</li></ol></blockquote><h4 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h4><blockquote><p>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</p></blockquote><h4 id="4-抽象"><a href="#4-抽象" class="headerlink" title="4.抽象"></a>4.抽象</h4><blockquote><p>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p></blockquote><h4 id="5-抽象和封装的不同点"><a href="#5-抽象和封装的不同点" class="headerlink" title="5.抽象和封装的不同点"></a>5.抽象和封装的不同点</h4><blockquote><p>抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</p></blockquote><h4 id="6-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#6-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="6.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>6.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h4><blockquote><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p></blockquote><h4 id="7-JDK和JRE的区别是什么？"><a href="#7-JDK和JRE的区别是什么？" class="headerlink" title="7.JDK和JRE的区别是什么？"></a>7.JDK和JRE的区别是什么？</h4><blockquote><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。<br>Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p></blockquote><h4 id="8-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#8-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="8.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>8.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h4><blockquote><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p></blockquote><h4 id="9-是否可以在static环境中访问非static变量？"><a href="#9-是否可以在static环境中访问非static变量？" class="headerlink" title="9.是否可以在static环境中访问非static变量？"></a>9.是否可以在static环境中访问非static变量？</h4><blockquote><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p></blockquote><h4 id="10-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#10-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="10.Java支持的数据类型有哪些？什么是自动拆装箱？"></a>10.Java支持的数据类型有哪些？什么是自动拆装箱？</h4><blockquote><p>Java语言支持的8中基本数据类型是：4种整型，2种浮点，1种字符，1种布尔</p><ol><li>byte占用8个字节</li><li>short占用16个字节</li><li>int占用32个字节</li><li>long占用64个字节</li><li>float占用32个字节</li><li>double占用64个字节</li><li>char占用16个字节</li><li>boolean占用1个字节</li></ol></blockquote><blockquote><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。</p></blockquote><h4 id="11-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#11-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="11.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>11.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h4><blockquote><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p></blockquote><h4 id="12-Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#12-Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="12.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>12.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h4><blockquote><p>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。<br>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p></blockquote><h4 id="13-Java支持多继承么？"><a href="#13-Java支持多继承么？" class="headerlink" title="13.Java支持多继承么？"></a>13.Java支持多继承么？</h4><blockquote><p>不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</p></blockquote><h4 id="14-接口和抽象类的区别是什么？"><a href="#14-接口和抽象类的区别是什么？" class="headerlink" title="14.接口和抽象类的区别是什么？"></a>14.接口和抽象类的区别是什么？</h4><blockquote><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p><ol><li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li><li>类可以实现很多个接口，但是只能继承一个抽象类</li><li>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li><li>抽象类可以在不提供接口方法实现的情况下实现接口。</li><li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li><li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li><li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</li></ol></blockquote><h4 id="15-什么是值传递和引用传递？"><a href="#15-什么是值传递和引用传递？" class="headerlink" title="15.什么是值传递和引用传递？"></a>15.什么是值传递和引用传递？</h4><blockquote><p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。<br>对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p></blockquote><h4 id="16-进程和线程的区别是什么？"><a href="#16-进程和线程的区别是什么？" class="headerlink" title="16.进程和线程的区别是什么？"></a>16.进程和线程的区别是什么？</h4><blockquote><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p></blockquote><h4 id="17-创建线程有几种不同的方式？哪一种更受欢迎？为什么？"><a href="#17-创建线程有几种不同的方式？哪一种更受欢迎？为什么？" class="headerlink" title="17.创建线程有几种不同的方式？哪一种更受欢迎？为什么？"></a>17.创建线程有几种不同的方式？哪一种更受欢迎？为什么？</h4><blockquote><p>有三种方式可以用来创建线程：</p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>应用程序可以使用Executor框架来创建线程池</li></ol></blockquote><blockquote><p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p></blockquote><h4 id="18-概括的解释下线程的几种可用状态。"><a href="#18-概括的解释下线程的几种可用状态。" class="headerlink" title="18.概括的解释下线程的几种可用状态。"></a>18.概括的解释下线程的几种可用状态。</h4><blockquote><p>线程在执行过程中，可以处于下面几种状态：<br>就绪(Runnable):线程准备运行，不一定立马就能开始执行。<br>运行中(Running)：进程正在执行线程的代码。<br>等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。<br>睡眠中(Sleeping)：线程被强制睡眠。<br>I/O阻塞(Blocked on I/O)：等待I/O操作完成。<br>同步阻塞(Blocked on Synchronization)：等待获取锁。<br>死亡(Dead)：线程完成了执行。</p></blockquote><h4 id="19-同步方法和同步代码块的区别是什么？"><a href="#19-同步方法和同步代码块的区别是什么？" class="headerlink" title="19.同步方法和同步代码块的区别是什么？"></a>19.同步方法和同步代码块的区别是什么？</h4><blockquote><p>在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。</p></blockquote><h4 id="20-什么是死锁-deadlock-？"><a href="#20-什么是死锁-deadlock-？" class="headerlink" title="20.什么是死锁(deadlock)？"></a>20.什么是死锁(deadlock)？</h4><blockquote><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p></blockquote><h4 id="21-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#21-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="21.如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>21.如何确保N个线程可以访问N个资源同时又不导致死锁？</h4><blockquote><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p></blockquote><h4 id="22-Java集合类框架的基本接口有哪些？"><a href="#22-Java集合类框架的基本接口有哪些？" class="headerlink" title="22.Java集合类框架的基本接口有哪些？"></a>22.Java集合类框架的基本接口有哪些？</h4><blockquote><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</p><ol><li>Collection：代表一组对象，每一个对象都是它的子元素。</li><li>Set：不包含重复元素的Collection。</li><li>List：有顺序的collection，并且可以包含重复元素。</li><li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li></ol></blockquote><h4 id="23-为什么集合类没有实现Cloneable和Serializable接口？"><a href="#23-为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="23.为什么集合类没有实现Cloneable和Serializable接口？"></a>23.为什么集合类没有实现Cloneable和Serializable接口？</h4><blockquote><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p></blockquote><h4 id="24-什么是迭代器-Iterator-？"><a href="#24-什么是迭代器-Iterator-？" class="headerlink" title="24.什么是迭代器(Iterator)？"></a>24.什么是迭代器(Iterator)？</h4><blockquote><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p></blockquote><h4 id="25-Iterator和ListIterator的区别是什么？"><a href="#25-Iterator和ListIterator的区别是什么？" class="headerlink" title="25.Iterator和ListIterator的区别是什么？"></a>25.Iterator和ListIterator的区别是什么？</h4><blockquote><ol><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ol></blockquote><h4 id="26-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#26-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="26.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>26.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h4><blockquote><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p></blockquote><h4 id="27-Java中的HashMap的工作原理是什么？"><a href="#27-Java中的HashMap的工作原理是什么？" class="headerlink" title="27.Java中的HashMap的工作原理是什么？"></a>27.Java中的HashMap的工作原理是什么？</h4><blockquote><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。<br>HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p></blockquote><h4 id="28-hashCode-和equals-方法的重要性体现在什么地方？"><a href="#28-hashCode-和equals-方法的重要性体现在什么地方？" class="headerlink" title="28.hashCode()和equals()方法的重要性体现在什么地方？"></a>28.hashCode()和equals()方法的重要性体现在什么地方？</h4><blockquote><p>Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</p></blockquote><h4 id="29-HashMap和Hashtable有什么区别？"><a href="#29-HashMap和Hashtable有什么区别？" class="headerlink" title="29.HashMap和Hashtable有什么区别？"></a>29.HashMap和Hashtable有什么区别？</h4><blockquote><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</p><ol><li>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</li><li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</li><li>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</li><li>一般认为Hashtable是一个遗留的类。</li></ol></blockquote><h4 id="30-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#30-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="30.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>30.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h4><blockquote><p>下面列出了Array和ArrayList的不同点：</p><ol><li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</li><li>Array大小是固定的，ArrayList的大小是动态变化的。</li><li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li><li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ol></blockquote><h4 id="31-ArrayList和LinkedList有什么区别？"><a href="#31-ArrayList和LinkedList有什么区别？" class="headerlink" title="31.ArrayList和LinkedList有什么区别？"></a>31.ArrayList和LinkedList有什么区别？</h4><blockquote><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</p><ol><li>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</li><li>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</li><li>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</li></ol></blockquote><h4 id="32-Comparable和Comparator接口是干什么的？列出它们的区别。"><a href="#32-Comparable和Comparator接口是干什么的？列出它们的区别。" class="headerlink" title="32.Comparable和Comparator接口是干什么的？列出它们的区别。"></a>32.Comparable和Comparator接口是干什么的？列出它们的区别。</h4><blockquote><p>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p></blockquote><h4 id="33-什么是Java优先级队列-Priority-Queue"><a href="#33-什么是Java优先级队列-Priority-Queue" class="headerlink" title="33.什么是Java优先级队列(Priority Queue)"></a>33.什么是Java优先级队列(Priority Queue)</h4><blockquote><p>PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p></blockquote><h4 id="34-你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#34-你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="34.你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>34.你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？</h4><blockquote><p>大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。<br>大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。</p></blockquote><h4 id="35-Java集合类框架的最佳实践有哪些？"><a href="#35-Java集合类框架的最佳实践有哪些？" class="headerlink" title="35.Java集合类框架的最佳实践有哪些？"></a>35.Java集合类框架的最佳实践有哪些？</h4><blockquote><p>根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。<br>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。<br>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。<br>使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。<br>编程的时候接口优于实现。<br>底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。</p></blockquote><h4 id="36-Enumeration接口和Iterator接口的区别有哪些？"><a href="#36-Enumeration接口和Iterator接口的区别有哪些？" class="headerlink" title="36.Enumeration接口和Iterator接口的区别有哪些？"></a>36.Enumeration接口和Iterator接口的区别有哪些？</h4><blockquote><p>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p></blockquote><h4 id="37-HashSet和TreeSet有什么区别？"><a href="#37-HashSet和TreeSet有什么区别？" class="headerlink" title="37.HashSet和TreeSet有什么区别？"></a>37.HashSet和TreeSet有什么区别？</h4><blockquote><p>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。<br>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</p></blockquote><h4 id="38-Java中垃圾回收有什么目的？什么时候进行垃圾回收？"><a href="#38-Java中垃圾回收有什么目的？什么时候进行垃圾回收？" class="headerlink" title="38.Java中垃圾回收有什么目的？什么时候进行垃圾回收？"></a>38.Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h4><blockquote><p>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p></blockquote><h4 id="39-System-gc-和Runtime-gc-会做什么事情？"><a href="#39-System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="39.System.gc()和Runtime.gc()会做什么事情？"></a>39.System.gc()和Runtime.gc()会做什么事情？</h4><blockquote><p>这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p></blockquote><h4 id="40-finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#40-finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="40.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>40.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h4><blockquote><p>在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。</p></blockquote><h4 id="41-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#41-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="41.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>41.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h4><blockquote><p>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p></blockquote><h4 id="42-Java中的两种异常类型是什么？他们有什么区别？"><a href="#42-Java中的两种异常类型是什么？他们有什么区别？" class="headerlink" title="42.Java中的两种异常类型是什么？他们有什么区别？"></a>42.Java中的两种异常类型是什么？他们有什么区别？</h4><blockquote><p>Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。</p></blockquote><h4 id="43-Java中Exception和Error有什么区别？"><a href="#43-Java中Exception和Error有什么区别？" class="headerlink" title="43.Java中Exception和Error有什么区别？"></a>43.Java中Exception和Error有什么区别？</h4><blockquote><p>Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。</p></blockquote><h4 id="44-throw和throws有什么区别？"><a href="#44-throw和throws有什么区别？" class="headerlink" title="44.throw和throws有什么区别？"></a>44.throw和throws有什么区别？</h4><blockquote><p>throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p></blockquote><h4 id="45-异常处理的时候，finally代码块的重要性是什么？"><a href="#45-异常处理的时候，finally代码块的重要性是什么？" class="headerlink" title="45.异常处理的时候，finally代码块的重要性是什么？"></a>45.异常处理的时候，finally代码块的重要性是什么？</h4><blockquote><p>无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。</p></blockquote><h4 id="46-异常处理完成以后，Exception对象会发生什么变化？"><a href="#46-异常处理完成以后，Exception对象会发生什么变化？" class="headerlink" title="46.异常处理完成以后，Exception对象会发生什么变化？"></a>46.异常处理完成以后，Exception对象会发生什么变化？</h4><blockquote><p>Exception对象会在下一个垃圾回收过程中被回收掉。</p></blockquote><h4 id="47-什么是JDBC？"><a href="#47-什么是JDBC？" class="headerlink" title="47.什么是JDBC？"></a>47.什么是JDBC？</h4><blockquote><p>JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。</p></blockquote><h4 id="48-数据库连接池是什么意思？"><a href="#48-数据库连接池是什么意思？" class="headerlink" title="48.数据库连接池是什么意思？"></a>48.数据库连接池是什么意思？</h4><blockquote><p>像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。</p></blockquote><h4 id="49-解释下Serialization"><a href="#49-解释下Serialization" class="headerlink" title="49.解释下Serialization"></a>49.解释下Serialization</h4><blockquote><p>Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。</p></blockquote><h4 id="50-什么是Servlet？"><a href="#50-什么是Servlet？" class="headerlink" title="50.什么是Servlet？"></a>50.什么是Servlet？</h4><blockquote><p>Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</p></blockquote><h4 id="51-说一下Servlet的体系结构。"><a href="#51-说一下Servlet的体系结构。" class="headerlink" title="51.说一下Servlet的体系结构。"></a>51.说一下Servlet的体系结构。</h4><blockquote><p>所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。</p></blockquote><h4 id="52-解释下Servlet的生命周期。"><a href="#52-解释下Servlet的生命周期。" class="headerlink" title="52.解释下Servlet的生命周期。"></a>52.解释下Servlet的生命周期。</h4><blockquote><p>服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(ServletConfig conf),该servlet对象去处理所有客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行,最后服务器关闭时，才会销毁这个servlet对象，执行destroy()方法。</p></blockquote><h4 id="53-doGet-方法和doPost-方法有什么区别？"><a href="#53-doGet-方法和doPost-方法有什么区别？" class="headerlink" title="53.doGet()方法和doPost()方法有什么区别？"></a>53.doGet()方法和doPost()方法有什么区别？</h4><blockquote><p>doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。<br>doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</p></blockquote><h4 id="54-什么是Web应用程序？"><a href="#54-什么是Web应用程序？" class="headerlink" title="54.什么是Web应用程序？"></a>54.什么是Web应用程序？</h4><blockquote><p>Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。</p></blockquote><h4 id="55-如何知道是哪一个客户端的机器正在请求你的Servlet？"><a href="#55-如何知道是哪一个客户端的机器正在请求你的Servlet？" class="headerlink" title="55.如何知道是哪一个客户端的机器正在请求你的Servlet？"></a>55.如何知道是哪一个客户端的机器正在请求你的Servlet？</h4><blockquote><p>ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。</p></blockquote><h4 id="56-HTTP响应的结构是怎么样的？"><a href="#56-HTTP响应的结构是怎么样的？" class="headerlink" title="56.HTTP响应的结构是怎么样的？"></a>56.HTTP响应的结构是怎么样的？</h4><blockquote><p>HTTP响应由三个部分组成：<br>状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。<br>HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。<br>主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</p></blockquote><h4 id="57-什么是cookie？session和cookie有什么区别？"><a href="#57-什么是cookie？session和cookie有什么区别？" class="headerlink" title="57.什么是cookie？session和cookie有什么区别？"></a>57.什么是cookie？session和cookie有什么区别？</h4><blockquote><p>cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：<br>无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。<br>在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。</p></blockquote><h4 id="58-sendRedirect-和forward-方法有什么区别？"><a href="#58-sendRedirect-和forward-方法有什么区别？" class="headerlink" title="58.sendRedirect()和forward()方法有什么区别？"></a>58.sendRedirect()和forward()方法有什么区别？</h4><blockquote><p>sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。</p></blockquote><h4 id="59-什么是URL编码和URL解码？"><a href="#59-什么是URL编码和URL解码？" class="headerlink" title="59.什么是URL编码和URL解码？"></a>59.什么是URL编码和URL解码？</h4><blockquote><p>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</p></blockquote><h4 id="60-什么是JSP页面？"><a href="#60-什么是JSP页面？" class="headerlink" title="60.什么是JSP页面？"></a>60.什么是JSP页面？</h4><blockquote><p>JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。</p></blockquote><h4 id="61-JSP请求是如何被处理的？"><a href="#61-JSP请求是如何被处理的？" class="headerlink" title="61.JSP请求是如何被处理的？"></a>61.JSP请求是如何被处理的？</h4><blockquote><p>浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。</p></blockquote><h4 id="62-JSP有什么优点？"><a href="#62-JSP有什么优点？" class="headerlink" title="62.JSP有什么优点？"></a>62.JSP有什么优点？</h4><blockquote><p>JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。<br>JSP页面可以被预编译。<br>JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。<br>开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。<br>开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</p></blockquote><h4 id="63-String，-Stringbuffer，-StringBuilder-的区别"><a href="#63-String，-Stringbuffer，-StringBuilder-的区别" class="headerlink" title="63.String， Stringbuffer， StringBuilder 的区别"></a>63.String， Stringbuffer， StringBuilder 的区别</h4><hr><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-面向对象编程（OOP）&quot;&gt;&lt;a href=&quot;#1-面向对象编程（OOP）&quot; class=&quot;headerlink&quot; title=&quot;1.面向对象编程（OOP）&quot;&gt;&lt;/a&gt;1.面向对象编程（OOP）&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Java是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码开发模块化，更易维护和修改。&lt;/li&gt;
&lt;li&gt;代码复用。&lt;/li&gt;
&lt;li&gt;增强代码的可靠性和灵活性。&lt;/li&gt;
&lt;li&gt;增加代码的可理解性。&lt;/li&gt;
&lt;li&gt;面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/tags/Java/"/>
    
      <category term="面试题" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用函数整理</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Mysql常用函数整理/</id>
    <published>2018-03-15T14:59:24.000Z</published>
    <updated>2018-03-16T09:27:50.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>经常编写程序的一定体会得到函数的重要性，丰富的函数往往能让工作事半功倍。</strong></p></blockquote><a id="more"></a><h4 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1.字符串函数"></a>1.字符串函数</h4><table><thead><tr><th>函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td>concat(S1,S2,…Sn)</td><td style="text-align:left">连接 S1,S2,…Sn 为一个字符串</td></tr><tr><td>insert(str,x,y,instr)</td><td style="text-align:left">将字符串 str 从 x 位置开始，y 个字符长的子串替换为 instr</td></tr><tr><td>lower(str)</td><td style="text-align:left">将字符串 str 中所有字符变为小写</td></tr><tr><td>upper(str)</td><td style="text-align:left">将字符串 str 中所有字符变为大写</td></tr><tr><td>left(str,x)</td><td style="text-align:left">返回字符串 str 最左边的 x 个字符</td></tr><tr><td>right(str,x)</td><td style="text-align:left">返回字符串 str 最左边的 x 个字符</td></tr><tr><td>lpad(str,n,pad)</td><td style="text-align:left">用字符串 pad 对 str 最左边进行填充，知道长度为n个字符串</td></tr><tr><td>rpad(str,n,pad)</td><td style="text-align:left">用字符串 pad 对 str 最右边进行填充，知道长度为n个字符串</td></tr><tr><td>ltrim(str)</td><td style="text-align:left">去掉字符串 str 左侧的空格</td></tr><tr><td>rtrim(str)</td><td style="text-align:left">去掉字符串 str 右侧的空格</td></tr><tr><td>repeat(str,x)</td><td style="text-align:left">返回 str 重复 x 次的结果</td></tr><tr><td>replace(str,a,b)</td><td style="text-align:left">用字符串 b 替换字符串 str 中所有出现的字符串 a</td></tr><tr><td>strcmp(s1,s2)</td><td style="text-align:left">比较字符串 s1 和 s2</td></tr><tr><td>trim(str)</td><td style="text-align:left">去掉字符串 str 行尾和行头的空格</td></tr><tr><td>substring(str,x,y)</td><td style="text-align:left">返回从字符串str x 位置起 y 个字符长度的字串</td></tr></tbody></table><h4 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2.数值函数"></a>2.数值函数</h4><table><thead><tr><th>函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td>abs(x)</td><td style="text-align:left">返回 x 的绝对值</td></tr><tr><td>ceil(x)</td><td style="text-align:left">返回大于 x 的最小正整数值</td></tr><tr><td>floor(x)</td><td style="text-align:left">返回小于 x 的最大正整数值</td></tr><tr><td>mod(x,y)</td><td style="text-align:left">返回 x/y 的模</td></tr><tr><td>rand()</td><td style="text-align:left">返回 0~1 内的随机值</td></tr><tr><td>round(x,y)</td><td style="text-align:left">返回参数 x 的四舍五入的有 y 位小数的值</td></tr><tr><td>truncate(x,y)</td><td style="text-align:left">返回数字 x 截断为 y 位小数的结果</td></tr></tbody></table><h4 id="3-日期和时间的函数"><a href="#3-日期和时间的函数" class="headerlink" title="3.日期和时间的函数"></a>3.日期和时间的函数</h4><table><thead><tr><th>函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td>curdate()</td><td style="text-align:left">返回当前日期</td></tr><tr><td>curtime()</td><td style="text-align:left">返回当前时间</td></tr><tr><td>now()</td><td style="text-align:left">返回当前的日期和时间</td></tr><tr><td>unix_timestamp(data)</td><td style="text-align:left">返回日期date的UNIX时间戳</td></tr><tr><td>from_unixtime</td><td style="text-align:left">返回UNIX时间戳的日期值</td></tr><tr><td>week(date)</td><td style="text-align:left">返回日期date为一年中的第几周</td></tr><tr><td>year(date)</td><td style="text-align:left">返回日期date的年份</td></tr><tr><td>hour(time)</td><td style="text-align:left">返回time的小时值</td></tr><tr><td>minute(time)</td><td style="text-align:left">返回time的分钟值</td></tr><tr><td>monthname(date)</td><td style="text-align:left">返回date的月份名</td></tr><tr><td>date_format(date,fmt)</td><td style="text-align:left">返回按字符串 fmt 格式化日期 date 值</td></tr><tr><td>date_add(date,interval expr type)</td><td style="text-align:left">返回一个日期或时间值加上一个时间间隔的时间值</td></tr><tr><td>datediff(expr,expr2)</td><td style="text-align:left">返回起始时间 expr 和结束时间 expr2 之前的天数</td></tr></tbody></table><h4 id="4-MySQL中的日期和时间格式"><a href="#4-MySQL中的日期和时间格式" class="headerlink" title="4.MySQL中的日期和时间格式"></a>4.MySQL中的日期和时间格式</h4><table><thead><tr><th>格式符</th><th style="text-align:left">格式说明</th></tr></thead><tbody><tr><td>%S 和 %s</td><td style="text-align:left">两位数字形式的秒（00,01,…,59）</td></tr><tr><td>%i</td><td style="text-align:left">两位数字形式的分（00,01,…,59）</td></tr><tr><td>%H</td><td style="text-align:left">两位数字形式的小时，24小时（00,01,…,23）</td></tr><tr><td>%h 和 %I</td><td style="text-align:left">两位数字形式的小时，12小时（00,01,…,12）</td></tr><tr><td>%k</td><td style="text-align:left">数字形式的小时，24小时（0,1,…,23）</td></tr><tr><td>%1</td><td style="text-align:left">数字形式的小时，12小时（1,2,…,12）</td></tr><tr><td>%T</td><td style="text-align:left">24小时的时间形式（hh : mm : ss）</td></tr><tr><td>%r</td><td style="text-align:left">12小时的时间形式（hh : mm : ss AM或hh : mm : ss PM）</td></tr><tr><td>%p</td><td style="text-align:left">AM或PM</td></tr><tr><td>%W</td><td style="text-align:left">一周中每一天的名称（Sunday,Monday,…,Saturday）</td></tr><tr><td>%a</td><td style="text-align:left">一周中每一天名称的缩写（Sun,Mon,…,Sat）</td></tr><tr><td>%d</td><td style="text-align:left">两位数字表示月中的天数（00,01,…,31）</td></tr><tr><td>%e</td><td style="text-align:left">数字形式表示月中的天数（1,2,…,31）</td></tr><tr><td>%D</td><td style="text-align:left">英文后缀表示月中的天数（1st,2dn,3rd,…）</td></tr><tr><td>%w</td><td style="text-align:left">以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday）</td></tr><tr><td>%j</td><td style="text-align:left">以3位数字表示年中的天数（001,002,…,366）</td></tr><tr><td>%U</td><td style="text-align:left">周（0,1,52）,其中Sunday为周中的第一天</td></tr><tr><td>%u</td><td style="text-align:left">周（0,1,52）,其中Monday为周中的第一天</td></tr><tr><td>%M</td><td style="text-align:left">月名（January,February,…,December）</td></tr><tr><td>%b</td><td style="text-align:left">缩写的月名（January,February,…,December）</td></tr><tr><td>%m</td><td style="text-align:left">两位数字表示的月份（01,02,…,12）</td></tr><tr><td>%c</td><td style="text-align:left">数字表示的月份（1,2,…,12）</td></tr><tr><td>%Y</td><td style="text-align:left">4位数字表示的年份</td></tr><tr><td>%y</td><td style="text-align:left">两位数字表示的年份</td></tr><tr><td>%%</td><td style="text-align:left">直接值“%”</td></tr></tbody></table><h4 id="5-流程函数"><a href="#5-流程函数" class="headerlink" title="5.流程函数"></a>5.流程函数</h4><table><thead><tr><th>函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td>IF(value,t f)</td><td style="text-align:left">如果value是真，返回t；否则返回f</td></tr><tr><td>IFNULL(value1，value2)</td><td style="text-align:left">如果value1不为空，返回value1；否则返回value2</td></tr><tr><td>CASE WHEN[value1] THEN[result1]… ELSE[default]END</td><td style="text-align:left">如果value1是真，返回result1；否则返回default</td></tr><tr><td>CASE [expr] WHEN [value1] THEN [result1] … ELSE[default]END</td><td style="text-align:left">如果expr等于value1，返回result；否则返回default</td></tr></tbody></table><h4 id="6-其他常用函数"><a href="#6-其他常用函数" class="headerlink" title="6.其他常用函数"></a>6.其他常用函数</h4><table><thead><tr><th>函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td>datebase()</td><td style="text-align:left">返回当前数据库名</td></tr><tr><td>version()</td><td style="text-align:left">返回当前数据库版本</td></tr><tr><td>user()</td><td style="text-align:left">返回当前登录用户名</td></tr><tr><td>inet_aton(IP)</td><td style="text-align:left">返回IP地址的数字表示</td></tr><tr><td>inet_ntoa(num)</td><td style="text-align:left">返回数字代表的IP地址</td></tr><tr><td>password(str)</td><td style="text-align:left">返回字符串str的加密版本</td></tr><tr><td>MD5()</td><td style="text-align:left">返回字符串str的MD5值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;经常编写程序的一定体会得到函数的重要性，丰富的函数往往能让工作事半功倍。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://cq-harry.github.io/Harry.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://cq-harry.github.io/Harry.github.io/tags/Mysql/"/>
    
      <category term="常用函数" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Set和List 的关系与区别</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Set%E5%92%8CList-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Set和List-的关系与区别/</id>
    <published>2018-03-15T14:49:54.000Z</published>
    <updated>2018-03-16T09:39:12.249Z</updated>
    
    <content type="html"><![CDATA[<p><strong>两个接口都是继承自Collection</strong></p><a id="more"></a><ul><li><p>List (inteface)</p><p><strong>次序是List 的最重要特点,它确保维护元素特定的顺序.</strong></p><ul><li>ArrayList：允许对元素快速随机访问。</li><li>LinkedList：对顺序访问进行优化，向List中间插入与移除的开销并不大，具有addFrist()，addLast()，getFirst，getLast，removeFirst和removeLast()。这些方法使得LinkedList可当作堆栈／队列／双向队列。</li></ul></li><li><p>Set (inteface)</p><p><strong>存入Set 的每个元素必须唯一，不保证维护元素的次序.加入Set 的Object必须定义equals()方法</strong></p><ul><li>HashSet：为快速查找而设计的Set，存入HashSet对象必须定义hashCode()。</li><li>TreeSet：保护次序的Set，使用它可以从Set 中提取有序序列。</li><li>LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的次序。</li></ul></li></ul><p><strong>它们之间的存储方式不一样：</strong></p><ul><li>TreeSet采用红黑树的树据结构排序元素；</li></ul><ul><li>HashSet采用散列函数，这是专门为快速查询而设计的；</li><li>LinkedHashSet内部使用散列以加快查询速度，同时使用链表维护元素的次序。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;两个接口都是继承自Collection&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/tags/Java/"/>
    
      <category term="Set" scheme="https://cq-harry.github.io/Harry.github.io/tags/Set/"/>
    
      <category term="List" scheme="https://cq-harry.github.io/Harry.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>mysql 存储实例</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/mysql-存储过程/</id>
    <published>2018-03-15T14:46:04.000Z</published>
    <updated>2018-03-16T01:14:29.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sql拼接注意："><a href="#sql拼接注意：" class="headerlink" title="sql拼接注意："></a>sql拼接注意：</h3><h4 id="单双引号"><a href="#单双引号" class="headerlink" title="单双引号"></a>单双引号</h4><h4 id="like查询"><a href="#like查询" class="headerlink" title="like查询"></a>like查询</h4><a id="more"></a><h4 id="临时表更新涉及到时间的字段最好加默认时间："><a href="#临时表更新涉及到时间的字段最好加默认时间：" class="headerlink" title="临时表更新涉及到时间的字段最好加默认时间："></a>临时表更新涉及到时间的字段最好加默认时间：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//数据更新的时候，时间会同步更新</span><br><span class="line">create_time timestamp not null,</span><br><span class="line">//更改后</span><br><span class="line">create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</span><br></pre></td></tr></table></figure><h4 id="能通过拼接实现的sql，尽量不用‘？’来替换参数"><a href="#能通过拼接实现的sql，尽量不用‘？’来替换参数" class="headerlink" title="能通过拼接实现的sql，尽量不用‘？’来替换参数"></a>能通过拼接实现的sql，尽量不用‘？’来替换参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数替换</span><br><span class="line">set @ssra = CONCAT(@ssra,&apos;where u.parent_id = ?&apos;);</span><br><span class="line">EXECUTE sqlquery USING @parent_id;</span><br><span class="line">//SQL拼接</span><br><span class="line">set @ssra = CONCAT(@ssra,&quot; and u.nick_name like &apos;%&quot;,@user_name,&quot;%&apos;&quot;);</span><br></pre></td></tr></table></figure><p><strong><em>参数值是desc、asc，实现前端传值排序，目前只知道拼接来实现，‘？’形式会抱错</em></strong></p><h3 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">-- 导出 yiyi_db 的数据库结构</span><br><span class="line">CREATE DATABASE IF NOT EXISTS `yiyi_db` /*!40100 DEFAULT CHARACTER SET utf8 */;</span><br><span class="line">USE `yiyi_db`;</span><br><span class="line"></span><br><span class="line">-- 导出  过程 yiyi_db.get_my_promotion_list 结构</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE DEFINER=`root`@`%` PROCEDURE `get_my_promotion_list`(</span><br><span class="line">IN `user_name` VARCHAR(50),</span><br><span class="line">IN `parent_id` CHAR(32),</span><br><span class="line">IN `time_order_by` VARCHAR(20),</span><br><span class="line">IN `deal_order_by` VARCHAR(20),</span><br><span class="line">IN `page_index` INT,</span><br><span class="line">IN `size` INT</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">set @user_name = user_name;</span><br><span class="line">set @parent_id = parent_id;</span><br><span class="line">set @time_order_by = time_order_by;</span><br><span class="line">set @deal_order_by = deal_order_by;</span><br><span class="line">set @page_index = page_index;</span><br><span class="line">set @size = size;</span><br><span class="line"></span><br><span class="line">create temporary table if not exists user_tmp(</span><br><span class="line">id char(32) not null,</span><br><span class="line">nick_name VARCHAR(100) DEFAULT NULL,</span><br><span class="line">upyun_url varchar(300) DEFAULT NULL,</span><br><span class="line">create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</span><br><span class="line">parent_id char(32) not null,</span><br><span class="line">volume bigint not null default 0</span><br><span class="line">)ENGINE = MEMORY ;</span><br><span class="line"></span><br><span class="line">begin </span><br><span class="line">set @ssra = CONCAT(&apos;insert into user_tmp(id,nick_name,upyun_url,create_time,parent_id ) &apos;);</span><br><span class="line">set @ssra = CONCAT(@ssra,&apos;SELECT &apos;);</span><br><span class="line">set @ssra = CONCAT(@ssra,&apos;u.id,u.nick_name,u.upyun_url,u.create_time,u.parent_id &apos;);</span><br><span class="line">set @ssra = CONCAT(@ssra,&apos;from user as u &apos;);</span><br><span class="line">set @ssra = CONCAT(@ssra,&apos;where u.parent_id = ?&apos;);</span><br><span class="line">if @user_name &lt;&gt; &apos;&apos; then</span><br><span class="line">set @ssra = CONCAT(@ssra,&quot; and u.nick_name like &apos;%&quot;,@user_name,&quot;%&apos;&quot;);</span><br><span class="line">end if;</span><br><span class="line"></span><br><span class="line">PREPARE sqlquery FROM @ssra;</span><br><span class="line">EXECUTE sqlquery USING @parent_id;</span><br><span class="line"></span><br><span class="line">set @ssra = concat(&apos;update user_tmp u set volume = &apos;);</span><br><span class="line">set @ssra = concat(@ssra ,&apos; (select count(po.id) from product_order po where po.buyer_id = u.id)&apos;);</span><br><span class="line"></span><br><span class="line">PREPARE sqlquery FROM @ssra;</span><br><span class="line">EXECUTE sqlquery;</span><br><span class="line">   </span><br><span class="line">set @ssra = concat(&apos;select * from user_tmp &apos;);</span><br><span class="line"></span><br><span class="line">if @time_order_by &lt;&gt; &apos;&apos; and @deal_order_by &lt;&gt; &apos;&apos; then </span><br><span class="line">set @ssra = concat(@ssra,&apos;order by volume &apos;, @deal_order_by,&apos;,create_time &apos;,@time_order_by);</span><br><span class="line">elseif @time_order_by = &apos;&apos; and @deal_order_by = &apos;&apos; then</span><br><span class="line">set @ssra = concat(@ssra,&apos;order by volume desc,create_time desc&apos;);</span><br><span class="line">else </span><br><span class="line">if @time_order_by &lt;&gt; &apos;&apos; then</span><br><span class="line">set @ssra = concat(@ssra,&apos; order by create_time &apos;,@time_order_by);</span><br><span class="line">end if;</span><br><span class="line">if @deal_order_by &lt;&gt; &apos;&apos; then</span><br><span class="line">set @ssra = concat(@ssra,&apos; order by volume &apos;,@deal_order_by);</span><br><span class="line">end if;</span><br><span class="line">end if;</span><br><span class="line">   </span><br><span class="line">set @ssra = concat(@ssra, &apos; limit ?,? &apos;);</span><br><span class="line"></span><br><span class="line">PREPARE sqlquery FROM @ssra;</span><br><span class="line">EXECUTE sqlquery USING @page_index,@size;</span><br><span class="line"></span><br><span class="line">   DROP TEMPORARY TABLE IF EXISTS user_tmp;</span><br><span class="line">end;</span><br><span class="line">END</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;sql拼接注意：&quot;&gt;&lt;a href=&quot;#sql拼接注意：&quot; class=&quot;headerlink&quot; title=&quot;sql拼接注意：&quot;&gt;&lt;/a&gt;sql拼接注意：&lt;/h3&gt;&lt;h4 id=&quot;单双引号&quot;&gt;&lt;a href=&quot;#单双引号&quot; class=&quot;headerlink&quot; title=&quot;单双引号&quot;&gt;&lt;/a&gt;单双引号&lt;/h4&gt;&lt;h4 id=&quot;like查询&quot;&gt;&lt;a href=&quot;#like查询&quot; class=&quot;headerlink&quot; title=&quot;like查询&quot;&gt;&lt;/a&gt;like查询&lt;/h4&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://cq-harry.github.io/Harry.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://cq-harry.github.io/Harry.github.io/tags/Mysql/"/>
    
      <category term="存储过程" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 控制台不完全指南</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Chrome-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Chrome-控制台不完全指南/</id>
    <published>2018-03-15T14:44:12.000Z</published>
    <updated>2018-03-16T01:14:29.966Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome的开发者工具已经强大到没朋友的地步了，特别是其功能丰富界面友好的console，使用得当可以有如下功效：</p><p>更高「逼格」更快「开发调试」更强「进阶级的Frontender」<br>Bug无处遁形「Console大法好」<br><a id="more"></a><br>…….</p><p>转载自：<a href="http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html" target="_blank" rel="noopener">http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chrome的开发者工具已经强大到没朋友的地步了，特别是其功能丰富界面友好的console，使用得当可以有如下功效：&lt;/p&gt;
&lt;p&gt;更高「逼格」更快「开发调试」更强「进阶级的Frontender」&lt;br&gt;Bug无处遁形「Console大法好」&lt;br&gt;
    
    </summary>
    
      <category term="Chrome" scheme="https://cq-harry.github.io/Harry.github.io/categories/Chrome/"/>
    
    
      <category term="Chrome" scheme="https://cq-harry.github.io/Harry.github.io/tags/Chrome/"/>
    
      <category term="控制台" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E6%8E%A7%E5%88%B6%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中使用GIT基本操作</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8GIT%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/IDEA中使用GIT基本操作/</id>
    <published>2018-03-15T14:44:12.000Z</published>
    <updated>2018-05-02T07:10:54.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IDEA中使用GIT基本操作"><a href="#IDEA中使用GIT基本操作" class="headerlink" title="IDEA中使用GIT基本操作"></a>IDEA中使用GIT基本操作</h3><blockquote><p>假设小组中有两个人，组长A，组员B，国内推荐使用码云</p></blockquote><ol><li><p>A创建项目并提交到远程Git仓库</p><blockquote><p><strong>创建好项目，选择VCS - &gt; Import into Version Control -&gt; Create Git Repository</strong></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912161234797" alt="img"></p><p>​</p><p><strong>接下来指定本地仓库的位置，按个人习惯指定即可，例如这里选择了项目源代码同目录</strong></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912161334752" alt="img"></p><p>​</p><p><strong>点击OK后创建完成本地仓库，注意，这里仅仅是本地的。下面把项目源码添加到本地仓库。下图是Git与提交有关的三个命令对应的操作，Add命令是把文件从IDE的工作目录添加到本地仓库的stage区，Commit命令把stage区的暂存文件提交到当前分支的仓库，并清空stage区。Push命令把本地仓库的提交同步到远程仓库。</strong></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912164147415" alt="img"></p><p>​</p><p><strong>IDEA中对操作做了一定的简化，Commit和Push可以在一步中完成。</strong></p><p><strong>具体操作，在项目上点击右键，选择Git菜单</strong></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912165901032" alt="img">    </p><p>​</p><p><img src="https://img-blog.csdn.net/20160912165911954" alt="img"></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912165921938" alt="img"></p><p>​</p><p><strong>第一次提交，Push前需要指定远程仓库的地址。如下图，点击Define remote后，在弹出的窗口中输入远程仓库址。</strong></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912165942829" alt="img"></p></blockquote></li><li><p>B从远程Git仓库上获取项目源码</p><blockquote><p><strong>即克隆项目，操作如下：</strong></p><p><img src="https://img-blog.csdn.net/20160912170148207" alt="img"></p><p><strong>输入A–Push时填写的远程仓库地址</strong></p><p>​</p><p><img src="https://img-blog.csdn.net/20160912170214880" alt="img"></p><p><strong>接下来按向导操作，即可把项目从远程仓库克隆到本地仓库和IDE工作区。</strong></p></blockquote></li><li><p>B修改了部分源码，提交到远程仓库</p><blockquote><p><strong>这个操作和首次提交的流程基本一致，分别是 Add -&gt; Commit -&gt; Push。具体参考A首次提交项目操作</strong></p></blockquote></li><li><p>A从远程仓库获取B的提交</p><blockquote><p><strong>获取更新有两个命令：Fetch和Pull，Fetch是从远程仓库下载文件到本地的origin/master，然后可以手动对比修改决定是否合并到本地的master库。Push则是直接下载并合并。如果各成员在工作中都执行修改前先更新的规范，则可以直接使用Pull方式以简化操作。Fetch使用较少，基本使用Pull，IDEA集成的GIT工具处理代码冲突很方便。</strong></p><p><img src="https://img-blog.csdn.net/20160912170628933" alt="img"></p></blockquote></li><li><p>B接受了一个新功能的任务，创建了一个分支并在分支上开发</p><blockquote><p>建分支也是一个常用的操作，例如临时修改bug、开发不确定是否加入的功能等，都可以创建一个分支，再等待合适的时机合并到主干。</p><p>创建流程如下：</p><p><img src="https://img-blog.csdn.net/20160912171844429" alt="img"></p><p><img src="https://img-blog.csdn.net/20160912171858663" alt="img"></p><p>创建完成后注意IDEA的右下角，如下图，Git: wangpangzi_branch表示已经自动切换到wangpangzi_branch分支，当前工作在这个分支上。</p><p>点击后弹出一个小窗口，在Local Branches中有其他可用的本地分支选项，点击后选择Checkout即可切换当前工作的分支</p><p><img src="https://img-blog.csdn.net/20160912173123122" alt="img"></p><p>如下图，点击Checkout</p><p><img src="https://img-blog.csdn.net/20160912173307202" alt="img"></p><p><strong>注意，这里创建的分支仅仅在本地仓库，如果想让组长A获取到这个分支，还需要提交到远程仓库。</strong></p></blockquote></li><li><p>B把分支提交到远程Git仓库</p><blockquote><p>切换到新建的分支，使用Push功能</p><p><img src="https://img-blog.csdn.net/20160912173718844" alt="img"></p><p><img src="https://img-blog.csdn.net/20160912174243815" alt="img"></p></blockquote></li><li><p>A获取小袁提交的分支</p><blockquote><p><strong>使用Pull功能打开更新窗口，点击Remote栏后面的刷新按钮，会在Branches to merge栏中刷新出新的分支。这里并不想做合并，所以不要选中任何分支，直接点击Pull按钮完成操作。</strong></p><p><img src="https://img-blog.csdn.net/20160912174329143" alt="img"></p><p><strong>更新后，再点击右下角，可以看到在Remote Branches区已经有了新的分支，点击后在弹出的子菜单中选择Checkout as new local branch，在本地仓库中创建该分支。完成后在Local Branches区也会出现该分支的选项，可以按上面的方法，点击后选择Checkout切换。</strong></p><p><img src="https://img-blog.csdn.net/20160912174729488" alt="img"></p></blockquote></li><li><p>A把分支合并到主干</p><blockquote><p>新功能开发完成，体验很好，项目组决定把该功能合并到主干上。</p><p>切换到master分支，选择Merge Changes</p><p><img src="https://img-blog.csdn.net/20160912175201306" alt="img"></p><p>选择要合并的分支，点击Merge完成</p><p><img src="https://img-blog.csdn.net/20160912175359903" alt="img"></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IDEA中使用GIT基本操作&quot;&gt;&lt;a href=&quot;#IDEA中使用GIT基本操作&quot; class=&quot;headerlink&quot; title=&quot;IDEA中使用GIT基本操作&quot;&gt;&lt;/a&gt;IDEA中使用GIT基本操作&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设小组中有两个人
      
    
    </summary>
    
      <category term="IDEA" scheme="https://cq-harry.github.io/Harry.github.io/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="https://cq-harry.github.io/Harry.github.io/tags/IDEA/"/>
    
      <category term="GIT" scheme="https://cq-harry.github.io/Harry.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中Spring boot热部署 Thymeleaf警告</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/IDEA%E4%B8%ADSpring-boot%E7%83%AD%E9%83%A8%E7%BD%B2-Thymeleaf%E8%AD%A6%E5%91%8A/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/IDEA中Spring-boot热部署-Thymeleaf警告/</id>
    <published>2018-03-15T14:39:41.000Z</published>
    <updated>2018-03-16T01:14:29.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解决idea中Thymeleaf页面警告问题"><a href="#解决idea中Thymeleaf页面警告问题" class="headerlink" title="解决idea中Thymeleaf页面警告问题"></a>解决idea中Thymeleaf页面警告问题</h3><h4 id="maven-module-project项目会出现这个问题"><a href="#maven-module-project项目会出现这个问题" class="headerlink" title="maven module project项目会出现这个问题"></a>maven module project项目会出现这个问题</h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118004859_1.png" alt="id"><br><a id="more"></a></p><h4 id="解决方式在idea的官网也给出了答案，请点这个进入官网"><a href="#解决方式在idea的官网也给出了答案，请点这个进入官网" class="headerlink" title="解决方式在idea的官网也给出了答案，请点这个进入官网"></a>解决方式在idea的官网也给出了答案，请点这个<a href="https://www.jetbrains.com/help/idea/2016.3/thymeleaf.html#d397188e121" target="_blank" rel="noopener">进入官网</a></h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118089581_1.jpg" alt="id"></p><h4 id="按照官网的办法，我们进行一下设置，如下图："><a href="#按照官网的办法，我们进行一下设置，如下图：" class="headerlink" title="按照官网的办法，我们进行一下设置，如下图："></a>按照官网的办法，我们进行一下设置，如下图：</h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118132850_1.jpg" alt="id"></p><h3 id="idea-spring-boot热部署问题"><a href="#idea-spring-boot热部署问题" class="headerlink" title="idea spring boot热部署问题"></a>idea spring boot热部署问题</h3><p><strong>如果不重启服务，修改html文件是不生效的，这样我们开发效率会很低啊，所以我们要想办法让web容器像原来那样，可以进行自动刷新生效。</strong></p><h4 id="首先需要在pom-xml文件中引入devtools包"><a href="#首先需要在pom-xml文件中引入devtools包" class="headerlink" title="首先需要在pom.xml文件中引入devtools包"></a>首先需要在pom.xml文件中引入devtools包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="对idea进行一些配置"><a href="#对idea进行一些配置" class="headerlink" title="对idea进行一些配置:"></a>对idea进行一些配置:</h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118240583_1.jpg" alt="id"></p><h4 id="设置一下这个快捷键"><a href="#设置一下这个快捷键" class="headerlink" title="设置一下这个快捷键"></a>设置一下这个快捷键</h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118276468_1.jpg" alt="id"></p><h4 id="利用刚刚设置好的快捷键打开-Registry窗口，在蓝色的地方打钩"><a href="#利用刚刚设置好的快捷键打开-Registry窗口，在蓝色的地方打钩" class="headerlink" title="利用刚刚设置好的快捷键打开 Registry窗口，在蓝色的地方打钩"></a>利用刚刚设置好的快捷键打开 Registry窗口，在蓝色的地方打钩</h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118305304_1.jpg" alt="id"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;解决idea中Thymeleaf页面警告问题&quot;&gt;&lt;a href=&quot;#解决idea中Thymeleaf页面警告问题&quot; class=&quot;headerlink&quot; title=&quot;解决idea中Thymeleaf页面警告问题&quot;&gt;&lt;/a&gt;解决idea中Thymeleaf页面警告问题&lt;/h3&gt;&lt;h4 id=&quot;maven-module-project项目会出现这个问题&quot;&gt;&lt;a href=&quot;#maven-module-project项目会出现这个问题&quot; class=&quot;headerlink&quot; title=&quot;maven module project项目会出现这个问题&quot;&gt;&lt;/a&gt;maven module project项目会出现这个问题&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512118004859_1.png&quot; alt=&quot;id&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IDEA" scheme="https://cq-harry.github.io/Harry.github.io/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="https://cq-harry.github.io/Harry.github.io/tags/IDEA/"/>
    
      <category term="Spring Boot" scheme="https://cq-harry.github.io/Harry.github.io/tags/Spring-Boot/"/>
    
      <category term="Thymeleaf" scheme="https://cq-harry.github.io/Harry.github.io/tags/Thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>Java BigDecimal 小数点处理 计算</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/Java-BigDecimal-%E5%B0%8F%E6%95%B0%E7%82%B9%E5%A4%84%E7%90%86-%E8%AE%A1%E7%AE%97/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/Java-BigDecimal-小数点处理-计算/</id>
    <published>2018-03-15T14:37:35.000Z</published>
    <updated>2018-03-16T01:14:29.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="number">3.1415726</span>);</span><br><span class="line">b1 = b1.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">System.out.println(b1);</span><br><span class="line"><span class="comment">//输出：3.14</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(3);</span><br><span class="line">BigDecimal b2 = new BigDecimal(2);</span><br><span class="line">System.out.println(b1.add(b2));</span><br><span class="line">//输出：5</span><br></pre></td></tr></table></figure><h4 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(3);</span><br><span class="line">BigDecimal b2 = new BigDecimal(1);</span><br><span class="line">System.out.println(b1.subtract(b2));</span><br><span class="line">//输出：2</span><br></pre></td></tr></table></figure><h4 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(3);</span><br><span class="line">BigDecimal b2 = new BigDecimal(2);</span><br><span class="line">System.out.println(b1.multiply(b2));</span><br><span class="line">// 输出：6</span><br></pre></td></tr></table></figure><h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当发生除不尽的情况时，精确到小数点以后10位，以后的数字四舍五入</span><br><span class="line">BigDecimal b1 = new BigDecimal(13);</span><br><span class="line">BigDecimal b2 = new BigDecimal(3);</span><br><span class="line">System.out.println(b1.divide(b2, 10, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">// 输出：4.3333333333</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;四舍五入&quot;&gt;&lt;a href=&quot;#四舍五入&quot; class=&quot;headerlink&quot; title=&quot;四舍五入&quot;&gt;&lt;/a&gt;四舍五入&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BigDecimal b1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;number&quot;&gt;3.1415726&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b1 = b1.setScale(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, BigDecimal.ROUND_HALF_UP);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(b1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出：3.14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://cq-harry.github.io/Harry.github.io/tags/Java/"/>
    
      <category term="BigDecimal" scheme="https://cq-harry.github.io/Harry.github.io/tags/BigDecimal/"/>
    
  </entry>
  
  <entry>
    <title>maven 常用命令</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/maven-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/maven-常用命令/</id>
    <published>2018-03-15T10:11:59.000Z</published>
    <updated>2018-03-16T01:14:29.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="maven官方库："><a href="#maven官方库：" class="headerlink" title="maven官方库："></a>maven官方库：</h3><p><strong><a href="http://repo2.maven.org/maven2/" target="_blank" rel="noopener">http://repo2.maven.org/maven2/</a></strong></p><h3 id="阿里云镜像："><a href="#阿里云镜像：" class="headerlink" title="阿里云镜像："></a>阿里云镜像：</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><h3 id="maven依赖查询："><a href="#maven依赖查询：" class="headerlink" title="maven依赖查询："></a>maven依赖查询：</h3><p><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a></p><h3 id="maven常用命令："><a href="#maven常用命令：" class="headerlink" title="maven常用命令："></a>maven常用命令：</h3><h4 id="创建Maven的普通java项目"><a href="#创建Maven的普通java项目" class="headerlink" title="创建Maven的普通java项目"></a>创建Maven的普通java项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">-DgroupId=packageName</span><br><span class="line">-DartifactId=projectName</span><br></pre></td></tr></table></figure><h4 id="创建Maven的Web项目"><a href="#创建Maven的Web项目" class="headerlink" title="创建Maven的Web项目"></a>创建Maven的Web项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">-DgroupId=packageName</span><br><span class="line">-DartifactId=webappName</span><br><span class="line">-DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure><h4 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><h4 id="编译测试代码"><a href="#编译测试代码" class="headerlink" title="编译测试代码"></a>编译测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test -compile</span><br></pre></td></tr></table></figure><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure><h4 id="产生site"><a href="#产生site" class="headerlink" title="产生site"></a>产生site</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><h4 id="在本地Repository中安装jar"><a href="#在本地Repository中安装jar" class="headerlink" title="在本地Repository中安装jar"></a>在本地Repository中安装jar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><h4 id="清除产生的项目"><a href="#清除产生的项目" class="headerlink" title="清除产生的项目"></a>清除产生的项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><h4 id="生成eclipse项目"><a href="#生成eclipse项目" class="headerlink" title="生成eclipse项目"></a>生成eclipse项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn eclipse:eclipse</span><br></pre></td></tr></table></figure><h4 id="生成idea项目"><a href="#生成idea项目" class="headerlink" title="生成idea项目"></a>生成idea项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn idea:idea</span><br></pre></td></tr></table></figure><h4 id="组合使用goal命令，如只打包不测试"><a href="#组合使用goal命令，如只打包不测试" class="headerlink" title="组合使用goal命令，如只打包不测试"></a>组合使用goal命令，如只打包不测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -Dtest package</span><br></pre></td></tr></table></figure><h4 id="编译测试的内容"><a href="#编译测试的内容" class="headerlink" title="编译测试的内容"></a>编译测试的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test -compile</span><br></pre></td></tr></table></figure><h4 id="只打jar包"><a href="#只打jar包" class="headerlink" title="只打jar包"></a>只打jar包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn jar:jar</span><br></pre></td></tr></table></figure><h4 id="只测试而不编译，也不测试编译"><a href="#只测试而不编译，也不测试编译" class="headerlink" title="只测试而不编译，也不测试编译"></a>只测试而不编译，也不测试编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test -skipping compile -skinpping test -compile</span><br></pre></td></tr></table></figure><p><strong>-skipping的灵活运用，当然也可以用于其他组合命令</strong></p><h4 id="清除eclipse的一些系统设置"><a href="#清除eclipse的一些系统设置" class="headerlink" title="清除eclipse的一些系统设置"></a>清除eclipse的一些系统设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn eclipse:clean</span><br></pre></td></tr></table></figure><h4 id="显示版本信息"><a href="#显示版本信息" class="headerlink" title="显示版本信息"></a>显示版本信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;maven官方库：&quot;&gt;&lt;a href=&quot;#maven官方库：&quot; class=&quot;headerlink&quot; title=&quot;maven官方库：&quot;&gt;&lt;/a&gt;maven官方库：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://repo2.maven.org/maven2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://repo2.maven.org/maven2/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;阿里云镜像：&quot;&gt;&lt;a href=&quot;#阿里云镜像：&quot; class=&quot;headerlink&quot; title=&quot;阿里云镜像：&quot;&gt;&lt;/a&gt;阿里云镜像：&lt;/h3&gt;
    
    </summary>
    
      <category term="Maven" scheme="https://cq-harry.github.io/Harry.github.io/categories/Maven/"/>
    
    
      <category term="maven" scheme="https://cq-harry.github.io/Harry.github.io/tags/maven/"/>
    
      <category term="常用命令" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>IDEA控制台中文乱码解决方案</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/IDEA%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/IDEA控制台中文乱码解决方案/</id>
    <published>2018-03-15T10:10:23.000Z</published>
    <updated>2018-03-16T01:14:29.967Z</updated>
    
    <content type="html"><![CDATA[<h4 id="打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加："><a href="#打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加：" class="headerlink" title="打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加："></a>打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512117071813_1.png" alt="id"></p><h4 id="配置项目编码以及IDE编码："><a href="#配置项目编码以及IDE编码：" class="headerlink" title="配置项目编码以及IDE编码："></a>配置项目编码以及IDE编码：</h4><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512117128404_1.png" alt="id"></p><h4 id="配置项目启动服务器参数："><a href="#配置项目启动服务器参数：" class="headerlink" title="配置项目启动服务器参数："></a>配置项目启动服务器参数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><p><img src="http://cqhui.oss-cn-shenzhen.aliyuncs.com/1512117195505_1.png" alt="id"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加：&quot;&gt;&lt;a href=&quot;#打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加：&quot; class=&quot;headerlink&quot; title=&quot;打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加：&quot;&gt;&lt;/a&gt;打开Intellij的根目录，找到下图的两个文件（根据你的系统是32位或64位选择其中一个配置文件），在配置文件中添加：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-Dfile.encoding=UTF-8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="IDEA" scheme="https://cq-harry.github.io/Harry.github.io/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="https://cq-harry.github.io/Harry.github.io/tags/IDEA/"/>
    
      <category term="乱码" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux(CentOS) 下mysql自动备份</title>
    <link href="https://cq-harry.github.io/Harry.github.io/2018/03/15/linux-CentOS-%E4%B8%8Bmysql%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD/"/>
    <id>https://cq-harry.github.io/Harry.github.io/2018/03/15/linux-CentOS-下mysql自动备份/</id>
    <published>2018-03-15T10:08:36.000Z</published>
    <updated>2018-03-16T01:14:29.971Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建并编辑文件-data-mysqlBack-bakmysql"><a href="#创建并编辑文件-data-mysqlBack-bakmysql" class="headerlink" title="创建并编辑文件/data/mysqlBack/bakmysql"></a>创建并编辑文件/data/mysqlBack/bakmysql</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db_user=&quot;root&quot;</span><br><span class="line">db_passwd=&quot;root&quot;</span><br><span class="line">db_name=&quot;db_test&quot;</span><br><span class="line"># the directory for story your backup file.you shall change this dir</span><br><span class="line">backup_dir=&quot;/data/mysqlBack&quot;</span><br><span class="line"># date format for backup file (dd-mm-yyyy)</span><br><span class="line">time=&quot;$(date +&quot;%Y%m%d%H%M%S&quot;)&quot;     </span><br><span class="line"></span><br><span class="line">mysqldump -u$db_user  -p$db_passwd $db_name  &gt; &quot;$backup_dir/$db_name&quot;_&quot;$time.sql&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：-p和$db_passwd之间没有空格，不然$db_passwd会被当做参数[数据库名]来解析</p><a id="more"></a><h4 id="修改文件backmysql属性，使其可执行"><a href="#修改文件backmysql属性，使其可执行" class="headerlink" title="修改文件backmysql属性，使其可执行"></a>修改文件backmysql属性，使其可执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/sbin/bakmysql</span><br></pre></td></tr></table></figure><h4 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"> #进入编辑界面，内容如下</span><br><span class="line"></span><br><span class="line"> 00 22 * * * /data/mysqlBack/backmysq</span><br><span class="line"> #每天22:00执行backmysq文件，备份数据库在路径/data/mysqlBack/下</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;创建并编辑文件-data-mysqlBack-bakmysql&quot;&gt;&lt;a href=&quot;#创建并编辑文件-data-mysqlBack-bakmysql&quot; class=&quot;headerlink&quot; title=&quot;创建并编辑文件/data/mysqlBack/bakmysql&quot;&gt;&lt;/a&gt;创建并编辑文件/data/mysqlBack/bakmysql&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;db_user=&amp;quot;root&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db_passwd=&amp;quot;root&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db_name=&amp;quot;db_test&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# the directory for story your backup file.you shall change this dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;backup_dir=&amp;quot;/data/mysqlBack&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# date format for backup file (dd-mm-yyyy)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;time=&amp;quot;$(date +&amp;quot;%Y%m%d%H%M%S&amp;quot;)&amp;quot;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldump -u$db_user  -p$db_passwd $db_name  &amp;gt; &amp;quot;$backup_dir/$db_name&amp;quot;_&amp;quot;$time.sql&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：-p和$db_passwd之间没有空格，不然$db_passwd会被当做参数[数据库名]来解析&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://cq-harry.github.io/Harry.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://cq-harry.github.io/Harry.github.io/tags/Mysql/"/>
    
      <category term="linux" scheme="https://cq-harry.github.io/Harry.github.io/tags/linux/"/>
    
      <category term="CentOS" scheme="https://cq-harry.github.io/Harry.github.io/tags/CentOS/"/>
    
      <category term="自动备份" scheme="https://cq-harry.github.io/Harry.github.io/tags/%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
</feed>
